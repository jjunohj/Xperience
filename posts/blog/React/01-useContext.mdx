---
title: "Context API는 useState의 확장판이다"
description: "Context API로 지역적 상태 공유하기 - 전역 상태 라이브러리와 함께 사용하는 실용적 접근법"
summary: "Context API를 useState의 자연스러운 확장으로 이해하고, 전역 상태 라이브러리와 함께 사용하는 방법"
category: React
thumbnail: "/images/category-react.png"
tags:
  - React
  - Context API
  - useContext
  - useState
  - 상태 관리
date: 2025-06-14
---

## 들어가며

여러분은 React 프로젝트에서 상태 관리를 어떻게 하고 계신가요?

요즘은 보통 아래와 같이 상태관리를 하는 경우가 많은데요.

1. `useState`: 단일 컴포넌트의 상태 관리
2. 전역 상태 라이브러리 (Zustand, Recoil 등): 앱 전역에서 사용되며, 생명주기가 앱과 거의 동일한 상태 관리 (사용자 정보, 테마 등)
3. 서버 상태 관리 라이브러리 (React query, SWR 등): 서버로부터 받아오는 상태 관리 및 캐싱

여기서 한 가지 질문을 해보고 싶어요. 과연 Context API는 위 3가지 도구 중 몇 번에 해당할까요?

만약 2번이라고 생각하셨다면 여러분은 Context API를 여러가지 단점 때문에 실무에서 잘 쓰이지 않는 '전역 상태 관리 도구'로 알고 계셨을 확률이 높아요.

실제로 Context API를 구글에 검색해보면, '전역 상태 관리' 라는 말이 가장 많이 보이는 걸 확인할 수 있어요.

<img
  width="800"
  alt="Context API 검색 결과"
  src="https://xperiences-bucket.s3.ap-northeast-2.amazonaws.com/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2025-06-18+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+1.22.35.png"
/>

하지만, 사실 Context API는 전역 상태 관리가 **가능한** 도구이지, **전역 상태 관리를 위한 도구**가 아닙니다. 마치 망치로 나사를 돌릴 수는 있지만, 나사를 돌리는 용도로 망치를 사용하지 않는 것과 마찬가지죠.

그럼 망치, 아니, Context API는 어떤 용도로 사용하고, 언제 사용하는 것이 가장 효율적일까요?

이번 글에서는 Context API의 역할과 최적의 쓰임새를 깊이 있게 다루고, 특히 특정 영역에서 Context API가 얼마나 강력하고 우아한 도구가 될 수 있는지 보여드리고자 합니다.

## Context API란

Context API는 React의 컴포넌트 트리 안의 **특정 범위 내에서 상태를 공유**할 수 있도록 해주는 내장 기능입니다. 중요한 키워드는 바로 **특정 범위**인데요. Context API를 사용하면 컴포넌트 트리의 특정 범위 내에서는, 특정 컴포넌트로 데이터를 전달하기 위해 여러 컴포넌트를 거쳐 props를 내려주지 않고도 범위 내의 모든 컴포넌트에서 직접 값을 전달받을 수 있습니다.

Context API의 주요 구성 요소는 다음과 같습니다.

- `createContext` : 새로운 Context 객체를 생성합니다. 이 객체에는 Provider가 포함되어 있습니다.

- `Provider` : Context에 저장할 값을 하위 컴포넌트들에게 제공하는 역할을 합니다. Provider의 value prop을 통해 값을 전달합니다.

- `Consumer` 혹은 `useContext` : Context에 저장된 값을 구독하여 사용할 수 있게 해줍니다.

이해를 위해 아주 간단한 사용 예시를 보여드리겠습니다.

```
/* 1. Context로 공유할 Value 타입 정의 */
interface MyContextValue {
  name: string;
  age: number;
}

/* 2. Context 생성 */
const MyContext = createContext<MyContextValue | null>(null); // 초기값 null

const ParentComponent = () => {
  const [name, setName] = useState("John");
  const [age, setAge] = useState(20);

  /* 3. Context.Provider를 통해 영역 설정, 하위 컴포넌트에 값 전달 */
  return (
    <MyContext.Provider value={{ name, age }}>
      <ChildComponent />
    </MyContext.Provider>
  );
};

const ChildComponent = () => {
  /* 4. 영역 내의 컴포넌트에서 useContext를 통해 Context에 저장된 값 사용 */
  const { name, age } = useContext(MyContext);

  return (
    <div>
      <h1>{name}</h1>
      <p>{age}</p>
    </div>
  );
};
```

위 코드는 `ParentComponent`의 상태를 `MyContext` 값에 담고, 그 값을 공유할 범위인 `MyContext.Provider`에 감싸서 하위 컴포넌트에 전달하는 예시입니다.

이렇게 **특정 범위 내**에서 상태를 공유할 수 있다는 특성을 바탕으로, 그 범위를 애플리케이션 전체로 넓혀 전역에서 사용하도록 하면 Context API는 이제 **'전역 상태 관리 도구'**가 되는 겁니다.

하지만 이는 실무에서 크게 추천되지 않는 방식입니다. 바로 Context API의 또 다른 특성이자, 한계점 때문입니다.

## Context API의 한계

언뜻 보기에 Context API를 사용하면 굉장히 쉽고 직관적으로 전역 상태 관리가 가능할 것으로 보입니다. 그냥 Context에 전역으로 사용할 상태들을 담고, 애플리케이션 전체를 감싸버리면 끝이거든요. 하지만 Context API에는 크게 두 가지 한계점이 존재합니다.

### 1. 불필요한 리렌더링

- **Context의 value가 변경되면, 해당 Context를 구독하는 모든 컴포넌트가 리렌더링됩니다.**

- **Context에 여러 상태가 포함된 경우, 특정 상태 하나만 변경되어도 해당 상태와 무관한 컴포넌트까지 모두 리렌더링됩니다.**

아래 예시를 통해 문제를 구체적으로 살펴보겠습니다. 아래 코드는 사용자 정보와 테마 상태를 하나의 Context에 관리하는 예시입니다.

```
interface TotalContextValue {
  user: UserInfo;
  setUser: (user: UserInfo) => void;
  theme: Theme;
  setTheme: (theme: Theme) => void;
}

const TotalAppContext = createContext<TotalContextValue>({
  user: {
    name: "",
    email: "",
    phoneNumber: "",
  },
  theme: "light",
  setUser: () => {},
  setTheme: () => {},
});

const TotalAppProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<UserInfo>({
    name: "",
    email: "",
    phoneNumber: "",
  });
  const [theme, setTheme] = useState<Theme>("light");

  const value = { user, setUser, theme, setTheme };

  return (
    <TotalAppContext.Provider value={value}>
      {children}
    </TotalAppContext.Provider>
  );
};
```

위와 같은 상황일 때, 사용자가 `{children}` 내부의 특정 컴포넌트에서 `theme`을 변경했을 때 다음과 같은 일이 일어납니다.

1. `TotalAppProvider`의 `theme` 상태가 `"light"`에서 `"dark"`로 변경됩니다.
2. `TotalAppProvider` 컴포넌트가 리렌더링됩니다. **(1차 리렌더링 Point)**
3. 새로운 value 객체가 생성됩니다.
4. 이전 value 객체와 새로운 value 객체는 다른 참조를 가지므로, 이전 value 객체를 사용하는 모든 컴포넌트가 리렌더링됩니다. **(2차 리렌더링 Point)**

첫 번째로 부모가 렌더링되면, 기본적으로 그 자식들도 모두 렌더링된다는 React의 원칙에 따라 `TotalAppProvider`의 `{children}`들은 모두 리렌더링됩니다.

두 번째로 value의 prop 참조가 변경되었기 때문에, `useContext(TotalAppContext)`를 사용하는 모든 컴포넌트들 또한 Context 변경을 감지하고 리렌더링됩니다.

이 두 가지는 같은 시점에 발생하며, 결과적으로 **리렌더링**이라는 동일한 현상으로 이어집니다. 따라서, Context의 상태 변경이 빈번하거나, 컴포넌트 트리가 깊거나, 구독하는 컴포넌트가 많을수록 성능 저하 이슈가 발생합니다.

이 문제를 해결하기 위해 `useMemo`와 `React.memo`를 사용할 수 있지만, 이는 문제를 해결하는 것이 아니라 문제를 숨기는 것에 불과합니다. 또한, 이 방법은 컴포넌트 트리의 깊이가 증가하며, 중첩된 Provider(Provider Hell)가 발생하게 됩니다.

### 2. 다양한 상태 관리의 구조적 문제

- 여러 상태를 하나의 Context에 관리하면, 응집도가 떨어지고 value 변경에 의한 불필요한 리렌더링이 발생합니다.

- 여러 Context로 분리해서 사용하면, 중첩된 Provider(Provider Hell)가 발생하고, 연쇄적인 리렌더링이 발생할 수 있습니다.

아래 예시를 통해 문제를 구체적으로 살펴보겠습니다. 아래 코드는 사용자 정보와 테마 상태를 각각의 Context에 관리하는 예시입니다.

```
const UserContext = createContext<string>("");
const ThemeContext = createContext<string>("light");
const CartContext = createContext<string[]>([]);

const UserProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState("");
  return <UserContext.Provider value={user}>{children}</UserContext.Provider>;
};

const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  const [theme, setTheme] = useState("light");
  return (
    <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>
  );
};

const CartProvider = ({ children }: { children: React.ReactNode }) => {
  const [cart, setCart] = useState<string[]>([]);
  return <CartContext.Provider value={cart}>{children}</CartContext.Provider>;
};

const TotalAppProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <UserProvider>
      <ThemeProvider>
        <CartProvider>{children}</CartProvider>
      </ThemeProvider>
    </UserProvider>
  );
};
```

--주문하신 Provider Hell 코드가 완성되었습니다.--

---

Context를 도메인 별로 나누어 관리하면 응집도도 높아지고, value 변경에 따른 리렌더링도 줄일 수 있겠지만, 컴포넌트 트리의 깊이가 증가하며, 중첩된 Provider(Provider Hell)가 발생하게 됩니다.

**핵심은 '범위의 확장'입니다.** useState는 컴포넌트 하나, Context API는 Provider로 감싼 컴포넌트 트리 전체에서 상태를 공유합니다.

## 적재적소의 원칙: 언제 무엇을 사용할까?

모든 문제를 망치로만 해결할 필요는 없습니다. 상황에 맞는 도구를 사용하는 것이 더 효율적이에요.

### 전역 상태 라이브러리만 사용하면...

```tsx
// 이런 상태까지 전역으로 관리할 필요가 있을까요?
const useGlobalStore = create((set) => ({
  // 정말 전역적인 상태
  user: null,
  theme: "light",
  language: "ko",

  // 모달에서만 쓰는 상태들까지 전역으로...?
  modalStep: 1,
  modalFormData: {},
  modalError: null,

  // 회원가입 플로우에서만 쓰는 상태들까지...?
  signupStep: 1,
  signupEmail: "",
  signupPassword: "",

  // 파일 업로드에서만 쓰는 상태들까지...?
  uploadProgress: {},
  uploadErrors: {},
}));
```

전역 스토어가 이렇게 비대해지면 어떤 문제가 생길까요?

1. **관리 복잡성 증가**: 어떤 상태가 어디서 사용되는지 파악하기 어려움
2. **네임스페이스 오염**: 비슷한 이름의 상태들이 섞임
3. **불필요한 메모리 사용**: 사용이 끝난 임시 상태들이 계속 남아있음

### 역할별 분담 전략

저는 다음과 같은 기준으로 도구를 선택합니다:

**전역 상태 라이브러리 (Zustand, Recoil 등)**

- ✅ 앱 전체에서 사용하는 상태
- ✅ 복잡한 비즈니스 로직이 필요한 상태
- ✅ 서버 상태와 연동되는 상태

**Context API**

- ✅ 특정 기능/플로우에서만 사용하는 상태
- ✅ 몇 개의 관련된 컴포넌트끼리만 공유하는 상태
- ✅ 임시적이고 생명주기가 명확한 상태

**useState**

- ✅ 한 컴포넌트 내에서만 사용하는 상태

## 실제 사용 패턴과 폴더 구조

### 혼용 방식 (권장)

```
src/
├── stores/                    # 전역 상태
│   ├── userStore.ts          # 사용자 정보
│   ├── themeStore.ts         # 테마 설정
│   └── cartStore.ts          # 장바구니
├── components/
│   ├── checkout/             # 결제 기능
│   │   ├── CheckoutProvider.tsx    # Context API
│   │   ├── CheckoutFlow.tsx
│   │   ├── PaymentStep.tsx
│   │   └── ConfirmStep.tsx
│   ├── auth/                 # 인증 기능
│   │   ├── AuthProvider.tsx        # Context API
│   │   ├── LoginForm.tsx
│   │   ├── SignupForm.tsx
│   │   └── OtpForm.tsx
│   └── upload/               # 업로드 기능
│       ├── UploadProvider.tsx      # Context API
│       ├── FileDropZone.tsx
│       ├── ProgressBar.tsx
│       └── FileList.tsx
```

```tsx
// 전역 상태: 앱 전체에서 사용
const useUserStore = create((set) => ({
  user: null,
  isLoggedIn: false,
  setUser: (user) => set({ user, isLoggedIn: !!user }),
}));

const useThemeStore = create((set) => ({
  theme: 'light',
  toggleTheme: () => set((state) => ({
    theme: state.theme === 'light' ? 'dark' : 'light'
  })),
}));

// Context API: 결제 과정에서만 사용
const CheckoutProvider = ({ children }) => {
  const [step, setStep] = useState(1);
  const [items, setItems] = useState([]);
  const [shippingInfo, setShippingInfo] = useState({});
  const [paymentMethod, setPaymentMethod] = useState('');

  // 결제 완료되면 이 상태들은 자동으로 정리됨
  return (
    <CheckoutContext.Provider value={{...}}>
      {children}
    </CheckoutContext.Provider>
  );
};

// 함께 사용하는 예시
const CheckoutPage = () => {
  const { user } = useUserStore(); // 전역 상태
  const { theme } = useThemeStore(); // 전역 상태

  return (
    <div className={`checkout-page ${theme}`}>
      <h1>{user?.name}님의 주문</h1>
      <CheckoutProvider> {/* 지역적 상태 공유 */}
        <CheckoutFlow />
      </CheckoutProvider>
    </div>
  );
};
```

### 전역 상태만 사용하는 방식

```
src/
├── stores/
│   ├── userStore.ts
│   ├── themeStore.ts
│   ├── checkoutStore.ts      # 모든 상태를 전역으로
│   ├── authStore.ts
│   ├── uploadStore.ts
│   └── modalStore.ts
├── components/
│   ├── checkout/
│   │   ├── CheckoutFlow.tsx
│   │   ├── PaymentStep.tsx
│   │   └── ConfirmStep.tsx
│   ├── auth/
│   │   ├── LoginForm.tsx
│   │   ├── SignupForm.tsx
│   │   └── OtpForm.tsx
```

## 생명주기의 자연스러움

Context API의 큰 장점 중 하나는 **자동 정리**입니다.

```tsx
const SignupFlow = () => {
  return (
    <SignupProvider>
      {/* 회원가입 과정 */}
      <SignupSteps />
    </SignupProvider>
  );
};

// 회원가입이 완료되거나 사용자가 페이지를 떠나면
// SignupProvider의 모든 상태가 자동으로 정리됨
```

반면 전역 상태는 수동으로 정리해야 합니다:

```tsx
const useSignupStore = create((set) => ({
  step: 1,
  email: "",
  password: "",

  // 수동으로 정리 함수를 만들어야 함
  reset: () => set({ step: 1, email: "", password: "" }),
}));

// 어딘가에서 수동으로 호출해야 함
const handleSignupComplete = () => {
  useSignupStore.getState().reset();
};
```

## 실무 활용 사례

### 다단계 폼 관리

```tsx
// Context API로 폼 상태 관리
const FormProvider = ({ children }) => {
  const [currentStep, setCurrentStep] = useState(1);
  const [formData, setFormData] = useState({});
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const updateField = (field, value) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    // 에러가 있다면 지우기
    if (errors[field]) {
      setErrors((prev) => ({ ...prev, [field]: null }));
    }
  };

  const validateStep = () => {
    // 현재 스텝 검증 로직
  };

  const nextStep = () => {
    if (validateStep()) {
      setCurrentStep((prev) => prev + 1);
    }
  };

  return (
    <FormContext.Provider
      value={{
        currentStep,
        setCurrentStep,
        formData,
        updateField,
        errors,
        setErrors,
        isSubmitting,
        setIsSubmitting,
        nextStep,
        validateStep,
      }}
    >
      {children}
    </FormContext.Provider>
  );
};

// 각 스텝 컴포넌트에서 간편하게 사용
const Step1 = () => {
  const { formData, updateField, nextStep } = useFormContext();

  return (
    <div>
      <input
        value={formData.email || ""}
        onChange={(e) => updateField("email", e.target.value)}
      />
      <button onClick={nextStep}>다음</button>
    </div>
  );
};
```

### 모달 상태 관리

```tsx
const ModalProvider = ({ children }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [modalType, setModalType] = useState(null);
  const [modalProps, setModalProps] = useState({});

  const openModal = (type, props = {}) => {
    setModalType(type);
    setModalProps(props);
    setIsOpen(true);
  };

  const closeModal = () => {
    setIsOpen(false);
    // 애니메이션 후에 타입과 props 정리
    setTimeout(() => {
      setModalType(null);
      setModalProps({});
    }, 200);
  };

  return (
    <ModalContext.Provider
      value={{
        isOpen,
        modalType,
        modalProps,
        openModal,
        closeModal,
      }}
    >
      {children}
      {isOpen && <ModalRenderer type={modalType} props={modalProps} />}
    </ModalContext.Provider>
  );
};
```

## 성능 고려사항

### Context API 최적화

```tsx
// ✅ value 객체 메모이제이션
const MyProvider = ({ children }) => {
  const [state, setState] = useState(initialState);

  const value = useMemo(
    () => ({
      state,
      setState,
    }),
    [state],
  );

  return <MyContext.Provider value={value}>{children}</MyContext.Provider>;
};

// ✅ 상태를 기능별로 분리
const UserContextProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  // user 관련 상태만
};

const ThemeContextProvider = ({ children }) => {
  const [theme, setTheme] = useState("light");
  // theme 관련 상태만
};
```

### 선택적 구독 패턴

```tsx
// 필요한 값만 구독하는 커스텀 훅
const useFormField = (fieldName) => {
  const { formData, updateField } = useFormContext();

  const value = formData[fieldName];
  const setValue = useCallback(
    (newValue) => {
      updateField(fieldName, newValue);
    },
    [fieldName, updateField],
  );

  return [value, setValue];
};

// 사용
const EmailField = () => {
  const [email, setEmail] = useFormField("email");
  // email 필드만 변경되었을 때만 리렌더링
};
```

## 반대 의견에 대한 이해

**"전역 상태 라이브러리 하나로 통일"**을 선호하는 관점도 충분히 이해할 수 있습니다:

### 통일 방식의 장점

1. **일관성**: 모든 상태 관리 패턴이 동일
2. **러닝 커브**: 팀원들이 하나의 패턴만 학습하면 됨
3. **성능**: 이미 최적화가 잘 되어있음
4. **디버깅**: 하나의 도구로 모든 상태 추적 가능
5. **타입 안정성**: 전역 스토어의 타입 지원이 더 견고할 수 있음

### 혼용 방식의 단점

1. **복잡성**: 어떤 상황에서 무엇을 써야 할지 판단 필요
2. **일관성 부족**: 다양한 패턴이 혼재
3. **학습 비용**: 여러 도구를 모두 알아야 함

## 팀에서의 의사결정

결국 **팀의 합의와 일관성**이 가장 중요합니다.

### 고려해볼 요소들

1. **팀 규모**: 작은 팀이라면 혼용 방식의 유연성이 도움될 수 있음
2. **프로젝트 복잡도**: 복잡한 프로젝트라면 통일 방식이 관리하기 쉬울 수 있음
3. **팀 경험**: 팀원들의 React 경험 수준
4. **기존 코드베이스**: 이미 구축된 패턴이 있다면 그것을 따르는 것이 좋음

## 정리

### 제가 선호하는 접근법

저는 **"상황에 맞는 도구 선택"**을 선호합니다:

- **정말 전역적인 상태**: Zustand, Recoil 등
- **지역적 범위의 상태**: Context API
- **컴포넌트 내부 상태**: useState

### 핵심 포인트

1. **Context API는 useState의 자연스러운 확장**
2. **전역 상태 라이브러리와 경쟁하는 것이 아니라 함께 사용하는 것**
3. **생명주기가 명확한 임시 상태에는 Context API가 더 자연스러움**
4. **팀의 합의와 일관성이 더 중요**

### 상태 관리 도구 선택 가이드

1. **useState**: 한 컴포넌트 내에서만
2. **Context API**: 관련된 컴포넌트들 사이에서
3. **전역 상태 라이브러리**: 앱 전체에서

다음번에 "이 상태를 어떻게 관리하지?"라고 고민할 때, 세 가지 선택지를 모두 고려해보세요.

다만 팀에서 "전역 상태 라이브러리로 통일"하기로 했다면, 그것도 충분히 합리적인 선택입니다. **적재적소**보다는 **팀의 일관성**이 더 중요할 수 있으니까요.

Context API, 생각보다 어렵지 않죠? useState처럼 쉽고 자연스럽게 사용할 수 있는 도구입니다. 다음 프로젝트에서 한 번 시도해보세요!
