---

title: "Context API가 가장 빛나는 순간, 퍼널(Funnel)"

description: "Context API로 응집된 퍼널 스코프 상태 우아하게 관리하기"

summary: "Context API로 응집된 퍼널 스코프 상태 우아하게 관리하기"

category: React

thumbnail: "/images/category-react.png"

tags:

  - React

  - Context API

  - useContext

  - Funnel

date: 2025-06-14

---

## 들어가며

React에서 전역 상태 관리를 위해 어떤 도구를 사용하고 계신가요? Recoil? Jotai? 아니면 Zustand?

오늘은 조금 다른 이야기를 해보려고 합니다. 바로 Context API인데요.

최근 FE 생태계에서 개발을 시작하신 분들 중엔 'Context API는 props drilling을 해결하기 위해 나타났지만, 여러가지 단점들 때문에 잘 쓰이지 않고, 이젠 다른 툴들을 사용한다' 정도로만 알고 사용하지 않는 분들이 종종 있는 것 같아요.

물론 맞는 말이기도 합니다. 저 또한 일반적인 상황에서 전역 상태를 관리하기 위해 주로 Zustand나 Recoil같은 상태 관리 라이브러리를 사용하고 있습니다.

그럼 Context API는 구체적으로 어떠한 문제점 때문에 다른 라이브러리들에 밀려 잘 사용되지 않을까요? Context API를 잘 사용할 수 있는 방법은 정말 없을까요?

저는 그 해답을 여러 단계로 이루어진 '응집된 단계별 뷰 플로우', **퍼널(Funnel)**에서 찾게 되었습니다. 퍼널은 마케팅 용어지만, 여기서는 특정 작업을 위해 일련의 단계로 나뉘어진 뷰를 의미합니다.

## Context API란

Context API는 React의 컴포넌트 트리 안에서 데이터를 전역적으로 혹은 특정한 범위 내에서 공유할 수 있도록 해주는 내장 기능입니다.

기존에는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하려면 여러 단계를 거쳐 props를 내려주는 방식을 사용해야 했으나, Context API를 사용하면 중간 컴포넌트들을 굳이 거치지 않고도 원하는 컴포넌트에 직접 값을 전달할 수 있게 되었습니다.

Context API의 주요 구성 요소는 다음과 같습니다.

- `createContext` : 새로운 Context 객체를 생성합니다. 이 객체에는 Provider가 포함되어 있습니다.

- `Provider` : Context에 저장할 값을 하위 컴포넌트들에게 제공하는 역할을 합니다. Provider의 value prop을 통해 값을 전달합니다.

- `Consumer` 혹은 `useContext` : Context에 저장된 값을 구독하여 사용할 수 있게 해줍니다.

이해를 위해 아주 간단한 사용 예시를 보여드리겠습니다.

### Context API 사용 예시

```tsx
/* 1. Context로 공유할 Value 타입 정의 */

interface MyContextValue {
  name: string;

  age: number;
}

/* 2. Context 생성 */

const MyContext = createContext<MyContextValue | null>(null); // 초기값 null로 설정

const ParentComponent = () => {
  const [name, setName] = useState("John");

  const [age, setAge] =
    useState(20); /* 3. Context.Provider를 통해 하위 컴포넌트에 값 전달 */

  return (
    <MyContext.Provider value={{ name, age }}>
            <ChildComponent />   {" "}
    </MyContext.Provider>
  );
};

const ChildComponent = () => {
  /* 4. useContext를 통해 Context에 저장된 값 사용 */

  const { name, age } = useContext(MyContext);

  return (
    <div>
            <h1>{name}</h1>      <p>{age}</p>   {" "}
    </div>
  );
};
```

이렇게, Context API를 사용하면 특별히 props로 값을 전달하지 않아도 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 수 있습니다.

## Context API의 한계

언뜻 보기에 Context API를 사용하면 굉장히 쉽고 직관적으로 전역 상태 관리가 가능해 보입니다. 하지만 Context API에는 크게 두 가지 한계점이 존재합니다.

### 1. 불필요한 리렌더링

- **Context의 value가 변경되면, 해당 Context를 구독하는 모든 컴포넌트가 리렌더링됩니다.**

- **하나의 Context에 여러 상태가 포함된 경우, 특정 상태 하나만 변경되어도 해당 상태와 무관한 컴포넌트까지 모두 리렌더링됩니다.**

**결과적으로 상태 변경이 빈번하거나, 컴포넌트 트리가 깊거나, 구독하는 컴포넌트가 많을수록 성능 저하가 심해집니다.**

### 2. 다양한 상태 관리의 구조적 문제

- **여러 상태를 하나의 Context에 관리하면** → 관리가 복잡해지고 불필요한 리렌더링이 발생합니다.

- **여러 Context를 분리해서 사용하면** → Provider 중첩(Provider Hell)이 발생합니다.

아래 예시를 통해 리렌더링 문제를 구체적으로 살펴보겠습니다.

```tsx
interface TotalContextValue {
  user: string;

  setUser: (user: string) => void;

  theme: string;

  setTheme: (theme: string) => void;

  cart: string[];

  setCart: (cart: string[]) => void;
}

const TotalAppContext = createContext<TotalContextValue>({
  user: "",

  setUser: () => {},

  theme: "light",

  setTheme: () => {},

  cart: [],

  setCart: () => {},
});

const TotalAppProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState("");

  const [theme, setTheme] = useState("light");

  const [cart, setCart] = useState<string[]>([]);

  const value = { user, setUser, theme, setTheme, cart, setCart };

  return (
    <TotalAppContext.Provider value={value}>
            {children}   {" "}
    </TotalAppContext.Provider>
  );
};
```

위 코드에서 사용자가 테마를 변경하는 경우를 생각해보겠습니다.

```tsx
setTheme("dark"); // 'light'에서 'dark'로 테마 변경
```

1. **`theme` 상태가 `"light"`에서 `"dark"`로 변경됩니다.**

2. **`value` 객체가 새로운 참조를 가진 객체로 재생성됩니다.**

3. **Provider의 `value` prop이 변경되었으므로, `useContext(TotalAppContext)`를 사용하는 모든 컴포넌트가 리렌더링됩니다.**

즉, `user`, `theme`, `cart` 중 어떤 것 하나만 변경되어도 이 Context를 구독하는 모든 컴포넌트가 불필요하게 리렌더링되는 문제가 발생합니다.

이러한 문제를 해결하려면 각 상태를 별도의 Context로 분리해야 합니다.

```tsx
const UserContext = createContext<string>("");

const ThemeContext = createContext<string>("light");

const CartContext = createContext<string[]>([]);

const UserProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState("");

  return <UserContext.Provider value={user}>{children}</UserContext.Provider>;
};

const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>
  );
};

const CartProvider = ({ children }: { children: React.ReactNode }) => {
  const [cart, setCart] = useState<string[]>([]);

  return <CartContext.Provider value={cart}>{children}</CartContext.Provider>;
};

const TotalAppProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <UserProvider>
           {" "}
      <ThemeProvider>
                <CartProvider>{children}</CartProvider>     {" "}
      </ThemeProvider>
         {" "}
    </UserProvider>
  );
};
```

--짜잔 주문하신 Provider Hell 코드가 완성되었습니다.--

대충 감이 오시죠? **모든 상태를 하나의 Context에 넣으면 리렌더링 이슈가 발생하고, 여러개의 Context를 사용하면 Provider 중첩이 발생하게 됩니다.**

이러한 단점 때문에 대부분의 개발자들은 프로젝트 전반에 걸친 전역 상태를 관리할 때 Context API를 사용하지 않고, Zustand나 Recoil과 같은 상태 관리 라이브러리를 사용하고 있습니다.

주제에 맞게 전역 상태들을 정리할 수 있으면서, Provider 중첩과 구조적 문제를 해결하고, 각 전역 상태에서도 선택적으로 원하는 데이터만 구독할 수 있도록 하는 니즈를 바탕으로 말이죠.

그렇다면, 과연 Context API는 영원히 쓸 수 없는 기능일까요?

## Context API, 퍼널(Funnel)을 만나다.

저는 그 해답을 여러 단계로 구성된 UI 흐름, 즉 '퍼널(Funnel)' 구조를 다룰 때 찾았습니다.

최근 프론트엔드 진영에서는 여러 페이지나 컴포넌트에 걸쳐 이어지는 사용자 경험을 '퍼널'이라는 개념으로 다루고 있는데요. 튜토리얼, 회원 가입, 상품 구매 등 특정 목표를 위해 정해진 단계를 순차적으로 밟아나가는 과정을 깔때기에 빗댄 것입니다. 즉, 퍼널 구조는 특정 목표를 달성하기 위해 정해진 단계를 순차적으로 밟아나가는 과정을 의미합니다.

이러한 퍼널 구조는 다음과 같은 기술적 특징을 가집니다.

1. **높은 응집도:** 하나의 퍼널은 특정 도메인(e.g., 인증, 파일 업로드)에 관련된 로직, 상태, 컴포넌트를 하나의 단위로 묶어 관리합니다.

2. **상태의 지역성(Locality):** 퍼널 내에서 사용되는 상태는 해당 퍼널의 경계 안에서만 유효하며, 애플리케이션의 다른 부분에 영향을 주지 않습니다.

3. **제어된 뷰 전환:** 하나의 퍼널은 내부 상태에 따라 여러 하위 뷰(컴포넌트) 중 하나를 선택적으로 렌더링하는 경우가 많습니다.

이러한 특징들이 어떻게 Context API의 단점을 보완하고 장점을 극대화하는지, 실제 구현 사례를 통해 살펴보겠습니다.

자사 서비스의 경우, 로그인 시 다음과 같은 플로우를 통해 인증을 진행하는데, 이는 전형적인 퍼널 구조로 볼 수 있습니다.

![퍼널 구조](/images/blog/react/01-useContext/funnel.png)

예를 들어, 2FA가 활성화된 초기 생성 계정은 아래와 같은 단계로 퍼널이 진행됩니다.

- 1단계: 로그인 (LoginForm)

- 2단계: OTP 등록 (OtpRegisterForm)

- 3단계: OTP 입력 (OtpInputForm)

- 4단계: 비밀번호 변경 (ChangePasswordForm)

퍼널은 위와 같이 여러 개의 '스텝(Step)'으로 구성되며, 각 스텝은 독립적인 UI(컴포넌트)를 가집니다. 여기서 중요한 점은, 퍼널이 진행되는 동안 특정 상태가 모든 스텝에 걸쳐 공유되어야 한다는 것입니다.

### 퍼널 스코프 상태 (Funnel-Scoped State)

위 플로우에서, `step`, `otpToken`, `password` 와 같은 상태들은 프로젝트 전반에 걸친 전역 상태도, 특정 스텝 컴포넌트만의 지역 상태도 아닙니다. 오직 '인증 퍼널'이 시작될 때 생성되어, 퍼널이 진행되는 동안 공유되다가, 퍼널이 종료(성공 또는 이탈)되면 함께 소멸하는 생명주기를 가집니다.

우리는 이처럼 **'특정 퍼널 내에서만 유효한 상태'**를 **'퍼널 스코프 상태(Funnel-Scoped State)'**라고 부를 수 있습니다.

Context API는 바로 이 퍼널 스코프 상태를 담아두고 퍼널 내의 모든 스텝 컴포넌트에 공유하기 위한 가장 이상적인 도구입니다. AuthForm이라는 퍼널의 최상위 컴포넌트(오케스트레이터)가 AuthProvider를 통해 상태를 제공하면, 각 스텝 컴포넌트는 useAuthContext 훅으로 해당 상태에 손쉽게 접근할 수 있습니다.

먼저 AuthContext를 정의해봅시다.

```tsx
// AuthForm/data/types.ts

export interface AuthConfig {
  redirectPath: string;
}

export interface AuthNavigation {
  goToRedirectPath: () => void;

  goBackToLogin: () => void;
}

export type AuthFormStep =
  | "login"
  | "otpRegister"
  | "otpInput"
  | "changePassword";

export interface AuthState {
  step: AuthFormStep;

  otpToken: string;

  password: string;
}
```

```tsx
// AuthForm/data/AuthContext.tsx

import { createContext, useContext, ReactNode } from "react";

import { AuthConfig, AuthNavigation, AuthState } from "./types";

interface AuthContextValue extends AuthState, AuthConfig, AuthNavigation {}

const AuthContext = createContext<AuthContextValue | null>(null);

interface AuthProviderProps extends AuthState, AuthConfig, AuthNavigation {
  children: ReactNode;
}

export const AuthProvider = ({
  children,

  ...contextValue
}: AuthProviderProps) => {
  return (
    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>
  );
};

export const useAuthContext = () => {
  return useContext(AuthContext);
};
```

그다음, AuthForm 오케스트레이터 컴포넌트가 이 상태들을 관리하며 AuthProvider로 하위 컴포넌트(각 스텝)를 감싸줍니다.

```

// AuthForm.tsx

const AuthForm = ({redirectPath}: AuthConfig) => {

  const [step, setStep] = useState<AuthFormStep>("login");

  const [otpToken, setOtpToken] = useState("");

  const [password, setPassword] = useState("");



  const navigate = useNavigate();



  const goToRedirectPath = () => {

    navigate(redirectPath);

  };



  const goBackToLogin = () => {

    setStep("login");

    setOtpToken("");

  };



  // ... (생략) ...



  // Provider에 내려줄 값들을 객체로 묶어줍니다.

  const authConfig = { redirectPath };

  const authNavigation = { goToRedirectPath, goBackToLogin };

  const authState = { step, otpToken, password };



  // 현재 step에 맞는 뷰를 렌더링하는 함수

  const renderStep = () => {

    switch (step) {

      case "login":

        return <LoginForm />;

      case "otpRegister":

        return <OtpRegisterForm />;

      // ... 다른 스텝들 ...

      default:

        return null;

    }

  };



  return (

    <AuthProvider {...authConfig} {...authNavigation} {...authState}>

      {renderStep()}

    </AuthProvider>

  );

};



```

### Context API 한계, '퍼널' 관점에서 재해석하기

이러한 '퍼널' 관점은 Context API의 고질적인 한계를 명쾌하게 해소합니다.

1. 리렌더링 문제

'인증 퍼널'에서 Context의 값이 변경되는 시점은 step이 바뀌는, 즉 퍼널의 단계가 전환될 때입니다. 이는 곧 UI가 LoginForm에서 OtpInputForm으로 바뀌어야 함을 의미하며, 이 과정에서 발생하는 리렌더링은 불필요한 연산이 아니라 의도된 UI 업데이트입니다.

2. Provider 중첩 문제

AuthProvider는 전역 App 레벨이 아닌, AuthForm이라는 **'퍼널의 최상단'**에 국지적으로 선언됩니다. 따라서 다른 도메인의 Provider와 섞여 Provider Hell을 만들 여지가 없습니다. 오히려 '인증 퍼널'에 필요한 모든 의존성이 AuthForm 내부에 캡슐화되어 명확한 스코프를 가지게 됩니다.

결론: '퍼널 스코프 상태'를 위한 네이티브 솔루션

useFunnel과 같은 훌륭한 라이브러리들은 복잡한 퍼널 구조를 선언적으로 관리할 수 있게 도와줍니다. 하지만 모든 퍼널에 라이브러리가 필요한 것은 아닙니다.

AuthForm 예제처럼 퍼널의 로직이 하나의 컴포넌트 안에서 중앙 관리될 수 있는 경우, React에 내장된 Context API만으로도 충분히 우아하고 효율적으로 **'퍼널 스코프 상태'**를 관리할 수 있습니다.

이는 불필요한 외부 의존성을 줄이고, React의 기본 개념만으로도 복잡한 UI 흐름을 제어할 수 있다는 자신감을 심어줍니다.

다음에 여러 단계에 걸친 UI를 구현해야 할 때, '이거 퍼널 구조네?'라고 떠올려 보세요. 그리고 그 퍼널의 상태를 관리할 도구를 고민할 때, Context API를 가장 먼저 고려해보는 것은 어떨까요? 아마 기대 이상의 만족감을 얻게 될 겁니다.
