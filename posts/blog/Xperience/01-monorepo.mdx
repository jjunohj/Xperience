---
title: "스타트업 개발자의 모노레포 적용기 (Turborepo + Pnpm) 1편"
description: "레거시와의 전쟁, 모노레포의 등장 배경과 장단점, 채택 이유 등 솔직하게 공유하고 싶은 이야기"
category: Xperience
thumbnail: "/images/xperience-01-monorepo.png"
tags:
  - Turborepo
  - Monorepo
  - Pnpm
  - Storybook
  - TailwindCSS
date: 2024-10-14
---

## 시작하기 전에

이런 분들이 읽으시면 좋을 것 같아요.

- 각기 다른 기술과 레거시 코드로 이루어진 여러가지 프로젝트를 동시에 유지보수하고 있는 개발자 혹은 팀
- 모노레포에 대해 궁금한 개발자
- 모노레포를 도입하고 싶지만 어떻게 시작해야할지 모르는 개발자

## 스타트업의 첫 번째 정식 FE 개발자로 임명되다.

저는 2024년 8월 말, 보안과 해킹을 전문으로 하는 스타트업에서 웹 개발팀을 꾸린다는 소식에 지원 공고를 썼고, 몇 차례 채용 프로세스를 거쳐 첫 번째 정식 FE 개발자로 임명되었습니다.

지금까지 이렇다할 웹 개발팀 없이 사업을 굴려왔던 개발 조직에서 첫 번째 프론트엔드 엔지니어로 임명되었다는 것은 앞으로 펼쳐질 수많은 레거시 코드와 들어보지도 못한 기술들을 마주하게 될 것이라는 것을 의미했습니다.

- 각기 다른 팀원의 손을 조금씩 거쳐온 다양한 프레임워크/라이브러리의 다양한 프로젝트
- 2년 전에 지원이 중단된 Node 버전
- 존재하지 않는 코드 컨벤션
- 코드 정적 검사 및 테스팅 부재
- 프로젝트마다 다른 스타일 방식 (TailwindCSS, Emotion, CharkaUI, etc)
- deprecated된 빌드 도구와 빌드 방법의 차이
- 상태가 매우 심각한 UI/UX

타노스의 핑거스냅, 신창섭의 정상화가 필요했습니다.

당시 열정이 충만한 신입 개발자였던 저는 이러한 어려운 조건에서도 수많은 레포지토리와 버전 브랜치를 쉼 없이 넘나들고, 천차만별인 기술 스택을 초월하여 하루하루 고객사들의 이슈를 대응하고, 성능과 UI/UX를 개선했습니다.

하지만 이러한 방식으로는 업무 효율성이 점점 떨어져 결국 같은 일에 더욱 많은 시간과 노력을 들여야한다는 사실을 깨닫습니다.

기술 부채의 엄청난 무게로 인해 새로운 기술을 적용하긴 힘들어지고, 낡아버린 환경과 라이브러리의 아주 특별한 케이스를 위해 더욱 트릭키한 방식의 개발을 하게 됩니다. 이는 유지보수의 용이성을 저하시키고 잠재적으로는 회사의 성장과 개발자의 성장 모두를 막는 요소가 됩니다.

## 모노레포(Monorepo)란?

모노레포는 여러 개의 독립적인 프로젝트나 패키지를 하나의 저장소에서 관리하는 개발 방식입니다. 기존의 멀티레포(Multirepo) 방식과 달리, 모든 프로젝트가 동일한 저장소에서 버전 관리되며 빌드/테스트/배포 파이프라인을 공유합니다.

### 모노레포의 장점

1. **코드 재사용성 향상**

   - 공통 컴포넌트나 유틸리티를 쉽게 공유
   - 일관된 코드 스타일과 품질 유지 가능

2. **의존성 관리 간소화**

   - 프로젝트 간 의존성을 명확하게 관리
   - 패키지 버전 충돌 방지

3. **협업 효율성 증대**

   - 코드 변경사항을 한 번에 적용 가능
   - 프로젝트 간 코드 동기화가 용이

4. **빌드/배포 최적화**
   - 캐싱을 통한 빌드 성능 향상
   - 변경된 프로젝트만 선택적으로 빌드/배포 가능

### 모노레포의 단점

1. **저장소 크기 증가**

   - 모든 프로젝트 코드가 한 저장소에 있어 크기가 커짐
   - 초기 클론 시간이 길어질 수 있음

2. **복잡한 초기 설정**

   - 빌드/배포 파이프라인 구성이 복잡
   - 적절한 도구 선택과 설정이 필요

3. **접근 권한 관리의 어려움**
   - 프로젝트별 접근 권한 설정이 까다로움

## Turborepo와 Pnpm

### Turborepo

Turborepo는 JavaScript/TypeScript 모노레포를 위한 빌드 시스템입니다. 주요 특징은 다음과 같습니다:

- **캐싱**: 이전 빌드 결과를 재사용하여 빌드 시간 단축
- **병렬 실행**: 의존성 그래프에 따라 태스크를 병렬로 실행
- **원격 캐싱**: 팀원 간 빌드 캐시 공유 가능
- **프루닝**: 변경된 프로젝트만 선택적으로 빌드

### Pnpm

Pnpm은 효율적인 패키지 관리자로, 모노레포에서 특히 강점을 가집니다:

- **디스크 공간 절약**: 동일한 패키지를 하드 링크로 공유
- **엄격한 의존성**: 유령 의존성 방지
- **빠른 설치 속도**: 하드 링크를 활용한 효율적인 설치
- **Workspace 지원**: 모노레포 관리를 위한 내장 기능 제공

## Turborepo 세팅

```bash
pnpm dlx create-turbo@latest --example with-tailwind

./monorepo-fe -> pnpm 선택

cd monorepo-fe

pnpm dlx turbo login

pnpm setup

source ~/.zshrc

pnpm install turbo --global
```

```bash
// 오류 발생

 ERR_PNPM_NO_GLOBAL_BIN_DIR  Unable to find the global bin directory

// 해결

source ~/.zshrc
```

---

apps는 서비스 폴더,

packages는 서비스 간에 공통으로 사용할 패키지, 모듈들을 모아둡니다.

현재 apps에는 docs, web 서비스가 생성되었고, packages에는 모든 서비스에서 base로 사용할 eslint, tailwind, typescript 관련 세팅파일이 생성되었고, 공통으로 사용할 ui 컴포넌트 패키지가 담긴 ui 패키지가 생성되었습니다.

디자인 시스템을 apps 안에 넣는 기업도, packages안에 넣는 기업도 있습니다. 딱히 정답이 없기에 저는 디자인 시스템이 실제로 사내 네트워크에 배포되어 디자이너들이 언제든지 들어가 볼 수 있다는 점에서 하나의 사내 서비스라고 생각했고, 이 또한 다른 apps 내의 서비스들과 마찬가지로 별도의 CI/CD 파이프라인을 구축해야 한다는 점에서 apps 디렉토리 안에 만들어볼 예정입니다.

일단 이번 포스팅의 목표는 디자인 시스템의 src 폴더 내에 컴포넌트 구현을 진행하고, build 후 dist 폴더에 생성된 컴포넌트들을 다른 서비스에서 공통으로 사용하는 것 까지 천천히 진행해보려고 한다.

## Storybook 세팅

```bash
mkdir apps/design-system
cd apps/design-system

pnpm dlx storybook@latest init
>> React + TS 선택

(UI 라이브러리 키트 설치하고 싶을 경우)
pnpm install tailwindcss-radix --filter=stds
```

## Storybook Tailwind 세팅

```bash
pnpm install -D tailwindcss postcss autoprefixer --filter=stds

npx tailwindcss init -p
```

tailwind.config.js 파일에 tailwind를 사용해 개발한 Ui컨텐츠의 위치 경로를 삽입해 줍니다.

```jsx
// tailwind.config.js

/** @type {import('tailwindcss').Config} */
export default {
  content: ["./src/**/*.{js,jsx,ts,tsx}"], // src폴더 사용할 경우
  theme: {
    extend: {},
  },
  plugins: [],
};
```

src 내부의 모든 파일과 루트의 index.html은 사용하지 않을 예정이므로, 모두 삭제 한 뒤에, src 내에 새로 tailwind의 기본 설정 파일을 만들어 .storybook/preview.ts에 삽입해줍니다.

```css
// src/global.css

@tailwind base;
@tailwind components;
@tailwind utilities;
```

만약 이때 `@tailwind` 에 에디터상 경고가 뜬다면 이는 에디터 설정이므로, ~

```tsx
// .storybook/preview.ts

import "../src/global.css";
```

그리고 중첩된 CSS 문에 대한 설정을 진행해준다.

```tsx
// 경고

[vite:css] Nested CSS was detected, but CSS nesting has not been configured correctly.

// 해결

// postcss.config.js
module.exports = {
  plugins: {
    'postcss-import': {},
    'tailwindcss/nesting': {},
    tailwindcss: {},
    autoprefixer: {},
  }
}

pnpm install postcss-nesting --filter=stds

------

// 경고

Browserslist: caniuse-lite is outdated.

// 해결

npx update-browserslist-db@latest
pnpm up caniuse-lite
npx update-browserslist-db@latest
```

### Storybook Dark mode 세팅

```tsx
pnpm install @storybook/addon-themes --filter=stds
```

```jsx
// tailwind.config.js

/** @type {import('tailwindcss').Config} */
export default {
  content: ["./src/**/*.{js,jsx,ts,tsx}"], // src폴더 사용할 경우
  darkMode: ["class", '[data-mode="dark"]'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

```tsx
// .storybook/preview.ts

import type { Preview } from "@storybook/react";
import "../src/global.css";
import { withThemeByClassName } from "@storybook/addon-themes";

const preview: Preview = {
  parameters: {
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/i,
      },
    },
  },
};

export const decorators = [
  withThemeByClassName({
    themes: {
      light: "light",
      dark: "dark",
    },
    defaultTheme: "light",
  }),
];

export default preview;
```

### TwMerge, CVA를 활용한 Tailwind 스토리 예시

```tsx
pnpm install tailwind-merge class-variance-authority --filter=stds
```

이제 예시 파일을 한 번 생성해보자.

아래는 TwMerge, cva, tailwindcss를 활용해 만든 버튼 컴포넌트이다. 이를

- src/Button/index.tsx

- src/Button/Button.stories.tsx

이제 한 번 실행해보자

```tsx
pnpm run storybook
```

그러면 !!! 오류가 발생한다.. ㅎㅎ

```tsx
WARN No story files found for the specified pattern: src/**/*.mdx
```

```tsx
Unhandled promise rejection: [Failed to load PostCSS config: Failed to load PostCSS config (searchPath: /Users/junhocheong/monorepo_guide/apps/ds): [ReferenceError] module is not defined in ES module scope
This file is being treated as an ES module because it has a '.js' file extension and '/Users/junhocheong/monorepo_guide/apps/ds/package.json' contains "type": "module". To treat it as a CommonJS script, rename it to use the '.cjs' file extension.
```

하나는 아까 삭제해버린 src 내 파일들에 대한 다른 파일의 참조가 남아 있기 때문이고, 하나는 module이 ES module Scope로 정의되어 있지 않기 때문이라고 한다.

하나둘씩 해결해보자.

.storybook/main.ts에서 먼저 빨간 줄 떠 있는 반환 타입 any 사뿐히 삭제해주고, stories에서 기존 mdx파일에 대한 경로를 삭제해주자.

```tsx
// .storybook/main.ts

import type { StorybookConfig } from "@storybook/react-vite";

import { join, dirname } from "path";

/**
 * This function is used to resolve the absolute path of a package.
 * It is needed in projects that use Yarn PnP or are set up within a monorepo.
 */
function getAbsolutePath(value: string) {
  return dirname(require.resolve(join(value, "package.json")));
}
const config: StorybookConfig = {
  stories: ["../src/**/*.stories.@(js|jsx|mjs|ts|tsx)"],
  addons: [
    getAbsolutePath("@storybook/addon-onboarding"),
    getAbsolutePath("@storybook/addon-links"),
    getAbsolutePath("@storybook/addon-essentials"),
    getAbsolutePath("@chromatic-com/storybook"),
    getAbsolutePath("@storybook/addon-interactions"),
  ],
  framework: {
    name: getAbsolutePath("@storybook/react-vite"),
    options: {},
  },
};
export default config;
```

그리고 package.json에서 `"type": "module"` 와, `"private": true` 를 제거하고 다시 한 번 `pnpm run storybook`을 실행해보자.

### 짜잔~!

![스크린샷 2024-10-14 오후 3.45.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8a577f77-2a24-429c-9052-4a8af1ba4de2/877079f6-919d-4e4f-a63b-0d76358e5040/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.45.02.png)

dev 환경에서 src 내에 구현된 컴포넌트를 로컬로 띄우는 데 성공했다. 같은 네트워크를 사용중인 기기라면, 현재 기기의 IP주소에 6006 포트에 접속하면 동일한 화면을 확인할 수 있다.

이제 이 컴포넌트들을 apps 내의 서비스에서 사용해보도록 하자.

우선 src 내의 컴포넌트를 말아서 빌드를 먼저 해야 한다.

빌드를 하기 위해 tsup이라는 esbuild 기반 타입스크립트 번들러를 사용할 예정이다. tsup은 별도의 플러그인 설치 없이 cjs, esm 문법의 자바스크립트로 각각 따로 컴파일을 진행해준다.

먼저 tsup을 설치한다.

```tsx
pnpm install tsup --filter=ds
```

이후 ds의 루트에 tsup.config.ts파일을 만들고, 다음 내용을 붙여넣자.

```tsx
// /tsup.config.ts

import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts", "src/**/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  outDir: "dist",
});
```

그리고, config의 entry에 적혀있는대로, src파일 내부에 export 파일인 index.ts를 생성해주고, src 내부의 컴포넌트를 다음과 같이 import 해서 내보내자.

```tsx
// /src/index.ts

export { default as Button } from "./Button";
```

그리고 package.json을 다음과 같이 세팅해주면, 빌드 준비는 모두 끝났다.

```tsx
{
  "name": "ds",
  "version": "0.0.0",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.js"
    },
    "./*": {
      "types": "./dist/*/index.d.ts",
      "import": "./dist/*/index.mjs",
      "require": "./dist/*/index.js"
    }
  },
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "license": "MIT",
  "scripts": {
    "dev": "storybook dev -p 6006",
    "build": "tsup && storybook build"
  },
  "dependencies": {
    ...
  },
  "devDependencies": {
    ...
  },
  "eslintConfig": {
    "extends": [
      "plugin:storybook/recommended"
    ]
  }
}
```

빌드 전, 아까 생성되었던 공통 패키지 설정 파일을 ds 서비스에서 적용해주자.

먼저 package.json의 devDependencies에 다음 항목을 추가해주자.

```tsx
pnpm install @repo/eslint-config @repo/tailwind-config @repo/ty
pescript-config --filter=ds

"@repo/eslint-config": "workspace:*",
"@repo/tailwind-config": "workspace:*",
"@repo/typescript-config": "workspace:*",
```

여기서 왼쪽의 키값은 각 설정파일의 패키지 명이고, `“workspace:*”` 는 해당 패키지들이 같은 모노레포 내의 다른 워크스페이스에 있음을 나타낸다.

ds 서비스는 config-eslint의 library.js를, config-typescript에서 react-library.json을, config-tailwind에서 tailwind.config.ts를 불러와서 사용할 예정이다.

먼저 eslint.config.js를 다음과 같이 수정하자.

```tsx
// /eslint.config.js

module.exports = {
  extends: ["@repo/eslint-config/library.js"],
};
```

tsconfig는 3가지 파일이 존재하는데, 특별히 node환경과 app 환경을 별도로 구분할 것이 아니라면, tsconfig.app.json, tsconfig.node.json을 삭제하고, tsconfig.json를 다음과 같이 수정하자.

```tsx
// /tsconfig.json

{
  "extends": "@repo/typescript-config/react-library.json",
  "include": ["."],
  "exclude": ["dist", "build", "node_modules"]
}
```

빨간 줄이 생기는 부분은 현재 아까 package.json의 dev 디펜던시에 추가해준 설정이 아직 적용이 안되서 생기는 것이므로, 일단 무시해도 좋다.

그리고 tailwind.config.js를 다음과 같이 수정하고, 확장자를 `.ts`로 바꿔주자.

```tsx
// /tailwind.config.ts

import type { Config } from "tailwindcss";
import sharedConfig from "@repo/tailwind-config";

const config: Pick<Config, "prefix" | "presets" | "content"> = {
  content: ["./src/**/*.tsx"],
  presets: [sharedConfig],
};

export default config;
```

이제, 모노레포의 루트로 가서 pnpm install를 실행해주자.

```tsx
cd ../..
pnpm install
```

그러면 ds 내의 package.json의 설정에 따라 package 내의 설정 파일들을 잘 불러오고, 아까 있던 빨간 줄이 사라질 것이다. 실제로 ds폴더의 node_modules를 보면 `@repo` 내에 package의 설정값들이 잘 내려오는 것을 확인할 수 있다.

![스크린샷 2024-10-14 오후 4.29.30.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8a577f77-2a24-429c-9052-4a8af1ba4de2/d0cd3599-a3e5-454c-a1ff-affc4221ad23/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.29.30.png)

만약 그래도 빨간 줄이 해결이 안된다면, tsconfig.json의 `"extends": "@repo/typescript-config/react-library.json",` 를 지웠다가 다시 한 번 작성한 뒤에 저장해보고 그래도 안된다면 vscode를 껐다가 켜보길 바란다.

이제 빌드된 스토리북 파일의 경로를 루트에 세팅해주고, .gitignore에 추가해주자.

모노레포 루트의 turbo.json의 outputs 속성에 `"storybook-static/**"` 경로를 추가한다.

```tsx
// /turbo.json

{
  "$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", ".env*"],
      "outputs": [
        "dist/**",
        ".next/**",
        "!.next/cache/**",
        "storybook-static/**"
      ]
    },
    "lint": {},
    "type-check": {},
    "dev": {
      "cache": false,
      "persistent": true
    },
    "clean": {
      "cache": false
    }
  }
}

```

그리고 ds의 .gitignore에 `*storybook-static` 를 추가한다.

이제 모든 준비는 끝났다 ! 컴포넌트를 라이브러리 모듈로 빌드해보자 !

ds 디렉토리에서 `pnpm run build`를 해보자.

그럼 ds의 루트에 dist 폴더가 생기고, 그 안에 아주 예쁘게 말아진 cjs, esm 형식의 자바스크립트 파일과 타입을 확인할 수 있다 !!

참고로, 빌드 직후의 최종 ds의 폴더구조는 다음과 같다. 참고하길 바란다 !

![스크린샷 2024-10-14 오후 4.39.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8a577f77-2a24-429c-9052-4a8af1ba4de2/c3fa6636-2005-44bc-921d-dbcd621d1b35/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.39.07.png)

## apps에서 ds의 라이브러리 모듈 사용하기

다른 프로젝트에서 ds를 사용하기 위해선 아까와 같이 package.json에 디펜던시를 추가해주어야 한다.

web과 docs의 `package.json` 의 dependencies에 `"ds": "workspace:*",` 를 추가하자.

그리고 두 프로젝트의 tailwind.config.ts의 content에 불러온 node_modules/ds 에 대한 경로를 설정해주자.

```tsx
// /tailwind.config.ts

import type { Config } from "tailwindcss";
import sharedConfig from "@repo/tailwind-config";

const config: Pick<Config, "prefix" | "presets" | "content"> = {
  content: [
    "./src/**/*.{js,ts,jsx,tsx}",
    "./node_modules/ds/**/*.{js,ts,jsx,tsx}", // stds 패키지 포함
  ],
  presets: [sharedConfig],
};

export default config;
```

그리고 다시 모노레포 루트로 가서 `pnpm install`

그럼 설정은 모두 끝났다 !

이제 양 프로젝트에서 Button을 치면 자동완성으로 다음과 같이 import 할 수 있는 드롭다운이 열린다 !

![스크린샷 2024-10-14 오후 4.49.41.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8a577f77-2a24-429c-9052-4a8af1ba4de2/03c27f6d-77e7-4cf4-983d-94750bc0e49a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.49.41.png)

속성을 입력할 때도 미리 지정해놓은 옵션들이 자동완성으로 등장한다.

![스크린샷 2024-10-14 오후 4.50.01.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8a577f77-2a24-429c-9052-4a8af1ba4de2/5a77ecfa-b276-4dc0-a7ef-a4c6a85a9a09/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.50.01.png)

web과 docs 프로젝트에서 page.tsx를 다음과 같이 수정해보자.

```tsx
import { Button } from "ds";

export default function Page(): JSX.Element {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <Button variant="danger" size="lg" label="Hello, World!" />
    </main>
  );
}
```

그리고 모노레포 루트로 돌아가 turbo run dev를 실행하면..!

![스크린샷 2024-10-14 오후 4.53.08.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8a577f77-2a24-429c-9052-4a8af1ba4de2/34f77273-1343-4434-90d6-1e7c1cb5fcfa/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.53.08.png)

![스크린샷 2024-10-14 오후 4.53.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8a577f77-2a24-429c-9052-4a8af1ba4de2/6756e08a-b05e-4f5b-8150-20c3ec03a2ae/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.53.20.png)

짜잔 ..!

지금까지 pnpm turborepo를 활용한 모노레포에 tailwindcss, twMerge, cva를 이용한 공통 컴포넌트, Storybook 디자인 시스템, 해당 디자인 시스템을 이용하는 두 가지 프로젝트를 만들어 보았다.

```tsx
// src/Button/Button.stories.tsx

import type { Meta, StoryObj } from "@storybook/react";
import Button from ".";
import { fn } from "@storybook/test";

const meta: Meta<typeof Button> = {
  title: "Primitives/Button",
  tags: ["autodocs"],
  component: Button,
  parameters: {
    componentSubtitle: "다양한 스타일과 크기를 지원하는 버튼 컴포넌트",
    layout: "centered",
  },
};

export default meta;

type Story = StoryObj<typeof Button>;

export const Example: Story = {
  args: {
    label: "Button",
    variant: "primary",
    onClick: fn(() => alert("Hello")),
  },
  argTypes: {
    variant: {
      control: "radio",
      options: ["primary", "danger", "outlined", "subtle", "ghost", "link"],
      description: "버튼의 스타일 변형",
    },
    size: {
      control: "radio",
      options: ["sm", "md", "lg"],
      description: "버튼의 크기",
    },
    pill: {
      control: "boolean",
      description: "둥근 모양 여부",
    },
    disabled: {
      control: "boolean",
      description: "버튼 비활성화 여부",
    },
    loading: {
      control: "boolean",
      description: "로딩 상태 여부",
    },
    label: {
      control: "text",
      description: "버튼에 표시될 텍스트",
    },
    onClick: {
      description: "버튼 클릭 시 호출할 함수",
    },
  },
};
```

```tsx
// src/Button/index.tsx

import { twMerge } from "tailwind-merge";
import { cva } from "class-variance-authority";

const buttonStyles = cva(
  "w-fit rounded-lg justify-center items-center inline-flex cursor-pointer",
  {
    variants: {
      variant: {
        primary: "bg-slate-900 hover:bg-slate-700 active:bg-slate-600",
        danger: "bg-red-600 hover:bg-red-700 active:bg-red-800",
        outlined:
          "border border-slate-200 bg-white hover:bg-slate-50 active:bg-slate-100",
        subtle: "bg-slate-100 hover:bg-slate-200 active:bg-slate-300",
        ghost: "bg-white/opacity-0 hover:bg-slate-100 active:bg-slate-200",
        link: "bg-white/opacity-0 hover:underline",
      },
      size: {
        sm: "h-8 px-3 gap-x-1",
        md: "h-10 px-4 gap-x-1.5",
        lg: "h-12 px-5 gap-x-2",
      },
      pill: {
        true: "rounded-full",
      },
      loading: {
        true: "cursor-wait",
      },
      disabled: {
        true: "opacity-50 hover:bg- active:bg- cursor-not-allowed",
      },
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
    },
  },
);

const buttonTextStyles = cva(`font-normal font-sans my-auto`, {
  variants: {
    variant: {
      primary: "text-white",
      danger: "text-white",
      outlined: "text-slate-900",
      subtle: "text-slate-900",
      ghost: "text-slate-900",
      link: "text-slate-900",
    },
    size: {
      sm: "text-xs",
      md: "text-sm",
      lg: "text-lg",
    },
    loading: {
      true: "cursor-wait",
    },
    disabled: {
      true: "cursor-not-allowed",
    },
  },
  defaultVariants: {
    variant: "primary",
    size: "md",
  },
});

type ButtonVariant =
  | "primary"
  | "danger"
  | "outlined"
  | "subtle"
  | "ghost"
  | "link";
type ButtonSize = "sm" | "md" | "lg";

type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement>;
type DivProps = React.HTMLAttributes<HTMLDivElement> & {
  variant?: ButtonVariant;
  pill?: boolean;
  size?: ButtonSize;
  disabled?: boolean;
  label?: string;
  loading?: boolean;
  className?: string;
  onClick?: (e?: React.MouseEvent<HTMLDivElement | HTMLButtonElement>) => void;
};

const Button = ({
  variant = "primary",
  pill = false,
  size = "md",
  disabled = false,
  label = "",
  loading = false,
  className,
  onClick,
  ...props
}: ButtonProps & DivProps) => {
  return (
    <div
      className={twMerge(
        buttonStyles({ variant, size, pill, loading, disabled }),
        className,
      )}
      onClick={!loading && !disabled ? onClick : undefined}
    >
      <button
        className={twMerge(
          buttonTextStyles({ variant, size, loading, disabled }),
        )}
        disabled={disabled}
        {...props}
      >
        {label}
      </button>
    </div>
  );
};

export default Button;
```
