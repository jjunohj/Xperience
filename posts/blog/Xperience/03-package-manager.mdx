---
title: "지금 그 패키지 매니저, 왜 쓰시는 건지 설명할 수 있나요?"
description: "대표적인 패키지 매니저 소개와 특징"
category: Xperience
thumbnail: "/images/xperience-03-package-manager.png"
tags:
  - Npm
  - Pnpm
  - Yarn
  - Yarn berry
date: 2024-12-19
---

## 들어가기 전에

> 이런 분들이 읽으시면 좋을 것 같아요.
>
> - 지금까지 패키지 매니저를 당연하게 써왔지만, 왜 쓰는지 설명할 수 없는 개발자
> - 패키지 매니저의 동작 방식을 설명할 수 없는 개발자
> - 사용 중인 패키지 매니저의 채택 근거를 명확하게 설명할 수 없는 개발자

## 패키지 매니저와의 만남

여러분들이 프론트엔드 개발자로 프로젝트를 진행하게 된다면, 거의 무조건 패키지 매니저라는 녀석을 만나게 됩니다. (달랑 하나의 자바스크립트 파일을 만들어 아주 간단한 문법을 작성하는 것이 아니라면 말입니다.)

프로젝트를 깃에서 클론받은 뒤, `npm install`, `yarn install` 과 같은 명령어를 실행했을 것이고, 프로젝트를 로컬 환경에서 실행할 때도 `npm run dev`, `npm run start`, `yarn dev` 등 비슷비슷한 명령어들을 수도 없이 실행했을 것입니다.

첫 프론트엔드 개발을 시작할 때는 프로젝트를 실행하는 것조차 버겁기 때문에 지금 내가 뭘 설치하고 있는거고, 어떻게 이걸 실행했는 지에는 관심이 없습니다. **단지 실행이 되었다는 것.** 그것만이 중요하죠.

중간에 동료 개발자가 다른 패키지 매니저를 사용하자고 할 때도 그걸 왜 쓰는 지에 대해 그렇게 궁금하지 않습니다. 사용법은 비슷비슷하거든요. (설치.. 실행.. 빌드..!)

[이미지]

하지만 자연스럽게 개발 경험이 풍부해지고, 시야가 넓어지고, 프로젝트를 새로 진행하고 초기 설정을 하는 경우가 많아지면서, 늘 당연하게 써왔던 이 패키지 매니저에 은근한 궁금증이 생깁니다.

- 근데 그래서 얘가 왜 필요하지?
- 얘가 없으면 어떻게 되는거야?
- 종류는 또 왜 이렇게 많아?
- 뭐가 좋길래 이거 말고 이걸 쓰는거야?

이런 질문들이 생겨나기 시작합니다.

이제부터 이 궁금증들에 대해 하나둘씩 알아보도록 하겠습니다.

## 패키지 매니저의 등장

모든 기술의 등장에는 그 이유가 있습니다.

### 리부트 서버 시작

저와 함께 잠시 한 가지 상상을 해봅시다.

이제 여러분은 외부에서 아무런 코드도 가져올 수 없습니다.

`useState`훅이 필요하다면 직접 클로저를 통해 구현해서 사용해야 합니다. `Axios`의 JSON 파싱, 예외처리나, `React Query`의 데이터 캐싱이 필요하다면 다 직접 구현해야 합니다.

개발 리부트 서버 시작입니다. 개발 실력을 키우지 못하면 라이브러리의 편리함은 없습니다!

하지만 다행히 사교성이 좋은 여러분은 개발을 아주 잘하는 친구에게 연락해 친구표 라이브러리의 코드를 드르륵 긁어와서 여러분의 프로젝트에 복사해서 사용하게 됩니다.

하지만 에러가 발생합니다. 여러분의 프로젝트와 친구표 라이브러리가 **동일한 변수를 사용**하고 있었거든요. 이는 간단한 문제이므로 빠르게 수정하여 문제를 해결합니다.

그렇게 잠시 편안한 시간을 즐깁니다.
친구표 라이브러리에 문제가 생기기 전까지..

친구표 라이브러리에 문제가 발생하자 로직조차 모르는 여러분은 친구에게 연락해 이를 수정해달라고 합니다.
똑똑한 친구는 이를 곧바로 수정했고, 수정본을 파일로 보내줍니다.
이를 받아 다시 변수를 수정하고 프로젝트를 실행한 여러분은 갑자기 에러를 맞닥뜨리게 됩니다. 친구는 아주 잘만 실행되는데 말이죠.

알고보니, 친구표 라이브러리를 수정할 때 친구는 **또 다른 친구의 코드를 긁어와서 활용**했다고 합니다.

이제 여러분은 그 또 다른 친구의 코드를 찾아 여러분의 프로젝트에 복사해서 사용해야 할 것입니다. 부디 그 전에 또 겹치는 변수가 없길, 그리고 코드가 동일한 버전이길 바래야겠네요 !

어떤가요? 잠시 상상만 해보아도 버겁죠?

만약 패키지 매니저가 없다면, 이런 일이 실제로 벌어질 것입니다.

1. **수동 다운로드와 관리**

   - 필요한 라이브러리의 소스 코드를 직접 다운로드
   - 프로젝트 폴더에 수동으로 복사/붙여넣기
   - 버전 관리와 업데이트를 수작업으로 진행

2. **의존성 지옥**

   - 라이브러리 간의 의존성 관계를 수동으로 파악
   - 서로 다른 버전의 충돌 문제
   - 중복 라이브러리 설치로 인한 프로젝트 크기 증가

3. **표준화된 배포 방식 부재**
   - 라이브러리마다 다른 설치 방법
   - 일관된 버전 관리 체계 부재
   - 글로벌 네임스페이스 충돌 위험

이런 끔찍한 문제를 해결하기 위해 패키지 매니저가 등장했습니다.

## 패키지 매니저의 역할

패키지 매니저는 자바스크립트 프로젝트에서 사용하는 **의존성 관리 도구**입니다.

**의존성**이라고 함은, 말 그대로 프로젝트가 실행되기 위해 의존하는 외부 라이브러리, 모듈, 플로그인 등을 의미합니다.

패키지 매니저는 이러한 의존성들을 손쉽게 설치하고, 관리하는 역할을 합니다.

1. **표준화된 패키지 저장소**

   - npm registry를 통한 표준화된 패키지 배포
   - 검증된 패키지의 이름과 버전을 지정하여 쉽게 설치
   - 버전 관리 및 업데이트 자동화

2. **자동화된 의존성 관리**

   - 의존성 버전 명시 및 관리
   - 의존성 트리 분석 및 설치
   - 의존성 간 버전 충돌 감지 및 해결

3. **의존성 최적화**

   - 중복된 패키지 제거
   - 디스크 공간 절약
   - 설치 속도 개선
   - 탐색 속도 개선

4. **프로젝트 생명주기 관리**

   - 일관된 명령어 체계 (`install`, `run`, `build` 등)
   - 스크립트를 통한 작업 자동화

이처럼 패키지 매니저는 외부 라이브러리 없이 개발이 불가능한 시대에서 필수적인 도구입니다.

## 패키지 매니저 동작 방식

이제 패키지 매니저가 어떤 느낌으로 필수적이라는 건지는 감이 딱 잡혔습니다.

그럼 동작 방식을 알아보면서 조금만 기술적으로 더 딥하게 들어가볼게요.

패키지 매니저는 기본적으로 `Resolution`, `Fetch`, `Link` 이렇게 3가지 단계로 동작합니다.

### Resolution 단계

> - 라이브러리 버전 고정
> - 라이브러리의 다른 의존성 확인
> - 라이브러리의 다른 의존성 버전 고정

Resolution은 말 그대로 `해결` 단계입니다. 무언가 문제가 발생했기 때문에 해결 단계가 생겼겠죠?

우선 첫 번째 문제, **라이브러리 버전 고정**입니다. 앞선 예시에서, 여러분은 에러가 수정된 친구표 라이브러리를 찾아 복사해서 사용했습니다. 앞으로도 <u>에러가 해결된 버전 이후의 친구 코드</u>를 긁어와야 한다는 거죠.

패키지 매니저는 이를 수행하기 위해 `package.json` 파일에 의존성의 버전을 명시하고, 이 버전 표기의 규칙에 따라 의존성의 버전을 선택합니다. 예를 들어, `"react": "^18.2.0"`라고 명시되어 있으면, `^`이 나타내는 규칙에 따라 `≥ 18.2.0`, `< 19.0.0` 사이의 어떤 버전이든 사용할 수 있습니다. 패키지 매니저는 이 범위를 만족하는 선에서 가능한 최신 버전을 사용하려고 해요.

두 번째 발생하는 문제는 라이브러리가 사용하는 또다른 라이브러리, **의존성의 의존성 문제**입니다.

앞선 예시에서, 여러분은 에러가 수정된 친구표 라이브러리를 찾아 복사해서 사용했습니다. 하지만 친구표 라이브러리는 또 다른 라이브러리를 사용하고 있었죠. 그래서 여러분은 그 또 다른 라이브러리를 찾아 복사해서 사용해야 했습니다.

만약 여러분이 또 다른 라이브러리를 받아왔지만, 친구의 라이브러리에서 사용했던 라이브러리와 버전이 다를 때, 동일한 동작을 한다고 보장할 수 있을까요?

보장할 수 없습니다. 따라서 **의존성이 또 어떤 의존성을 가지는 지 확인하는 작업**이 꼭 필요합니다. 그리곤 그 **의존성의 의존성 버전도 고정하게 되고,** 마지막으로 그 결과물을 `package-lock.json` 혹은 `yarn.lock` 파일에 저장하게 됩니다.

그렇기 때문에 `package-lock.json` 혹은 `yarn.lock` 파일이 없을 경우 같은 `package.json`에 대해서도 사용하는 의존성 버전이 완전히 달라질 수 있게 됩니다.

이렇게 철저한 버전 고정을 통해 의존성 버전 문제를 해결하는 단계가 Resolution 단계입니다.

### Fetch 단계

> - 결정된 버전의 의존성들을 다운로드

Fetch는 Resolution 단계에서 결정된 버전을 기반으로 **의존성들을 다운로드**하는 아주 간단하고 심플한 단계예요.

### Link 단계

> - Resolution/Fetch 된 의존성들을 소스 코드에서 사용할 수 있는 환경을 제공

핵심인 Link 단계입니다.

다운로드 받은 의존성들을 실제로 **어떻게 프로젝트에 저장하고, 탐색하고, 사용하는 지를 결정하는 단계**예요.

대표적인 패키지 매니저들의 주요 차이점은 이 Link 단계에서 발생하는데요. 한 번 차근차근 살펴보도록 합시다.

## 대표적인 패키지 매니저

패키지 매니저에는 대표적으로 아래 4가지가 존재합니다.

- Npm
- Yarn Classic
- Yarn Berry
- Pnpm

### Npm (Node Package Manager)

Node.js 생태계의 가장 대표적인 패키지 매니저이자, 개발자들이 가장 익숙할 Npm입니다.

Npm은 `package.json`에서 명시하는 모든 의존성을 `node_modules` 폴더 밑에 하나하나씩 쓰는(저장하는) 방식인 npm Linker를 사용합니다.

만약 프로젝트에서 사용하는 의존성이 또 다른 의존성을 사용한다면, 그 의존성도 또 다시 해당 의존성의 `node_modules` 폴더 밑에 저장하게 됩니다.

```
reboot-project/
└─ node_modules/
   ├─ friend-library/
   |  └─ node_modules/
   |     └─ friend-friend-library
   └─ other-library/
      └─ node_modules/
          └─ other-library
```

결국 위와 같이 node_modules가 반복되는 형태가 되는 것이죠.

이런 방식은 프로젝트가 커질수록 문제가 됩니다.

import를 통해 의존성을 읽으려고 할 경우, 해당 의존성을 찾기 위해 node_modules를 타고타고 올라가면서 수많은 `node_modules`를 탐색해야합니다.

게다가 디스크 공간도 많이 차지하게 됩니다. 실제로 파일 시스템에 node_modules와 의존성이 저장되기 때문입니다.

예를 들어 만약 사용중인 100가지 의존성이 모두 똑같은 react 의존성을 사용한다고 가정할 경우, 의존성의 개수만큼 `node_modules/의존성1~100/node_modules/react/node_modules/...` 이런 식으로 의존성 100까지 저장되게 됩니다.

### Pnpm (Performant NPM)

이러한 npm의 단점 때문에 Pnpm이 등장하게 되었습니다.

Pnpm은 기존의 `node_modules` 폴더를 그대로 유지하면서 성능과 용량을 개선한 패키지 매니저입니다.

이를 가능하게 한 것은 바로 글로벌 저장소(`.pnpm-store`)와 하드 링크/심볼릭 링크 두 가지 기술입니다.

<details>
<summary>비전공자 분들을 위한 아주 쉽고 빠른 리눅스의 하드링크/심볼링 링크 설명 !</summary>

우리는 보통 파일 안에 데이터가 있다고 생각합니다. 즉, `클릭 => 파일명 A -> 데이터`라고 생각합니다.

하지만 그 사이에는 `inode`라는 녀석이 하나 더 있습니다. `inode`는 파일 시스템에서 파일의 실제 데이터가 어디에 저장되어 있는 지 가리키는 포인터입니다.

그리고 우리가 흔히 부르는 `파일`은 사실 이 `inode`를 가리키는 포인터입니다.

[이미지]

즉, `클릭 => 파일명 A -> inode #123 -> 실제 데이터` 이런 식으로 흘러가게 되는 것이죠.

### 하드 링크

하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킵니다.

```
파일명 A → inode #123 → 실제 데이터
파일명 B ↗
```

따라서 파일명 A(원본 파일)가 삭제되어도, 파일명 B(하드 링크)는 여전히 원본 파일의 inode를 가리키고 있기 떄문에, 파일명 B를 통해 원본 파일을 사용할 수 있습니다.

### 심볼링 링크 (소프트 링크)

심볼릭 링크는 파일이나 폴더를 가리키는 포인터 역할을 합니다. 쉽게 윈도우OS의 바로가기라고 생각하시면 편합니다.

따라서 원본 파일이 삭제되거나, 이동할 경우 심볼릭 링크는 더 이상 존재하지 않는 파일/디렉터리를 가리키게 되어 동작하지 않게 됩니다.

```
파일명 A → inode #123 → 실제 데이터
파일명 B → inode #124 → "파일명 A의 경로"
```

</details>

Pnpm은 의존성을 글로벌 저장소(`.pnpm-store`)에 딱 한 번만 저장한 뒤, 해당 의존성을 필요로 하는 프로젝트에는 글로벌 저장소의 의존성을 **하드 링크**로 참조하도록 합니다.

예를 들어 프로젝트에서 import를 통해 react를 사용한다고 가정해봅시다.

우선 node_modules/react를 찾아갑니다.

node_modules/react는 심볼릭 링크(바로가기)를 통해 node_modules/.pnpm/react/를 가리킵니다.

node_modules/.pnpm/react/는 하드 링크를 통해 .pnpm-store/react를 가리킵니다.

그리고 .pnpm-store/react는 실제 데이터를 저장하는 곳이죠.

```
.pnpm-store/
└── react의 실제 파일들
```

```
node_modules/
├── .pnpm/
│ └── react@18.2.0/
│    └── node_modules/
│       └── react/ <--- (.pnpm-store/react 와 하드링크)
└── react/ <--- (node_modules/.pnpm/react@18.2.0/node_modules/react 로 가는 심볼릭 링크)
```

## 출처

[Toss Tech - 패키지 매니저의 과거, 토스의 선택, 그리고 미래](https://toss.tech/article/lightning-talks-package-manager)

[어린소:티스토리 - 하드 링크/심볼링 링크](https://young-cow.tistory.com/44)
