---
title: "지금 그 패키지 매니저, 왜 쓰시는 건지 설명할 수 있나요?"
description: "대표적인 패키지 매니저 소개와 특징"
category: Xperience
thumbnail: "/images/xperience-03-package-manager.png"
tags:
  - npm
  - pnpm
  - yarn
  - yarn berry
date: 2024-12-19
---

## 들어가기 전에

> 이런 분들이 읽으시면 좋을 것 같아요.
>
> - 지금까지 패키지 매니저를 당연하게 써왔지만, 왜 쓰는지 설명할 수 없는 개발자
> - 패키지 매니저의 동작 방식을 설명할 수 없는 개발자
> - 현재 사용 중인 패키지 매니저와 다른 패키지 매니저 간의 차이점을 명확히 설명할 수 없는 개발자

## 패키지 매니저와의 만남

여러분들이 프론트엔드 개발자로 프로젝트를 진행하게 된다면, 거의 무조건 패키지 매니저라는 녀석을 만나게 됩니다. (달랑 하나의 자바스크립트 파일을 만들어 아주 간단한 문법을 작성하는 것이 아니라면 말입니다.)

프로젝트를 깃에서 클론받은 뒤, `npm install`, `yarn install` 과 같은 명령어를 실행했을 것이고, 프로젝트를 로컬 환경에서 실행할 때도 `npm run dev`, `npm run start`, `yarn dev` 등 비슷비슷한 명령어들을 수도 없이 실행했을 것입니다.

첫 프론트엔드 개발을 시작할 때는 프로젝트를 실행하는 것조차 버겁기 때문에 지금 내가 뭘 설치하고 있는거고, 어떻게 이걸 실행했는 지에는 관심이 없습니다. **단지 실행이 되었다는 것.** 그것만이 중요하죠.

중간에 동료 개발자가 다른 패키지 매니저를 사용하자고 할 때도 그걸 왜 쓰는 지에 대해 그렇게 궁금하지 않습니다. 사용법은 비슷비슷하거든요. (설치.. 실행.. 빌드..!)

[이미지]

하지만 자연스럽게 개발 경험이 풍부해지고, 시야가 넓어지고, 프로젝트를 새로 진행하고 초기 설정을 하는 경우가 많아지면서, 늘 당연하게 써왔던 이 패키지 매니저에 은근한 궁금증이 생깁니다.

- 근데 그래서 얘가 왜 필요하지?
- 얘가 없으면 어떻게 되는거야?
- 종류는 또 왜 이렇게 많아?
- 뭐가 좋길래 이거 말고 이걸 쓰는거야?

이런 질문들이 생겨나기 시작합니다.

이제부터 이 궁금증들에 대해 하나둘씩 알아보도록 하겠습니다.

## 패키지 매니저의 등장

모든 기술의 등장에는 그 이유가 있습니다.

### 리부트 서버 시작

저와 함께 잠시 한 가지 상상을 해봅시다.

이제 여러분은 외부에서 아무런 코드도 가져올 수 없습니다.

`useState`훅이 필요하다면 직접 클로저를 통해 구현해서 사용해야 합니다. `Axios`의 JSON 파싱, 예외처리나, `React Query`의 데이터 캐싱이 필요하다면 직접 다 구현해야 합니다.

개발 리부트 서버 시작입니다. 개발 실력을 키우지 못하면 라이브러리의 편리함은 없습니다!

하지만 다행히 사교성이 좋은 여러분은 개발을 아주 잘하는 친구에게 연락해 친구표 라이브러리의 코드를 드르륵 긁어와서 여러분의 프로젝트에 복사해서 사용하게 됩니다.

앗, 에러가 발생합니다. 여러분의 프로젝트와 친구표 라이브러리가 **동일한 변수명을 사용**하고 있었네요. 이는 간단한 문제이므로 빠르게 수정하여 문제를 해결합니다.

그렇게 잠시 편안한 시간을 즐깁니다.
친구표 라이브러리에 문제가 생기기 전까지..

친구표 라이브러리에 문제가 발생하자 로직조차 모르는 여러분은 친구에게 연락해 이를 수정해달라고 합니다.
똑똑한 친구는 이를 곧바로 수정했고, 수정본을 파일로 보내줍니다.
이를 받아 다시 변수를 수정하고 프로젝트를 실행한 여러분은 또다른 에러를 맞닥뜨립니다.
친구는 아주 잘만 실행된다고 하는데 말이죠.

알고보니, 친구표 라이브러리를 수정할 때 친구는 **또 다른 친구의 코드를 긁어와서 활용**했다고 합니다. 이런, 말을 해줘야지 !

이제 여러분은 그 또 다른 친구의 코드를 찾아 여러분의 프로젝트에 복사해서 사용해야 할 것입니다. 부디 그 전에 또 겹치는 변수가 없길, 그리고 코드가 친구에게 준 버전과 동일하길 바래야겠네요 !

어떤가요? 잠시 상상만 해보아도 버겁죠?

만약 패키지 매니저가 없다면, 이런 일이 실제로 벌어질 것입니다.

1. **수동 다운로드와 관리**

   - 필요한 라이브러리의 소스 코드를 직접 다운로드
   - 프로젝트 폴더에 수동으로 복사/붙여넣기
   - 버전 관리와 업데이트를 수작업으로 진행

2. **의존성 지옥**

   - 라이브러리 간의 의존성 관계를 수동으로 파악
   - 서로 다른 버전의 충돌 문제
   - 중복 라이브러리 설치로 인한 프로젝트 크기 증가

3. **표준화된 배포 방식 부재**
   - 라이브러리마다 다른 설치 방법
   - 일관된 버전 관리 체계 부재
   - 글로벌 네임스페이스 충돌 위험

이런 끔찍한 문제를 해결하기 위해 패키지 매니저가 등장했습니다.

## 패키지 매니저의 역할

패키지 매니저는 자바스크립트 프로젝트에서 사용하는 **의존성 관리 도구**입니다.

**의존성**이라고 함은, 말 그대로 프로젝트가 실행되기 위해 의존하는 외부 라이브러리, 모듈, 플러그인 등을 의미합니다.

패키지 매니저는 이러한 의존성들을 손쉽게 설치하고, 관리하는 역할을 합니다.

1. **표준화된 패키지 저장소**

   - npm registry를 통한 표준화된 패키지 배포
   - 검증된 패키지의 이름과 버전을 지정하여 쉽게 설치
   - 버전 관리 및 업데이트 자동화

2. **자동화된 의존성 관리**

   - 의존성 버전 명시 및 관리
   - 의존성 트리 분석 및 설치
   - 의존성 간 버전 충돌 감지 및 해결

3. **의존성 최적화**

   - 중복된 패키지 제거
   - 디스크 공간 절약
   - 설치 속도 개선
   - 탐색 속도 개선

4. **프로젝트 생명주기 관리**

   - 일관된 명령어 체계 (`install`, `run`, `build` 등)
   - 스크립트를 통한 작업 자동화

이처럼 패키지 매니저는 외부 라이브러리 없이 개발이 불가능한 시대에서 필수적인 도구입니다.

## 패키지 매니저 동작 방식

이제 패키지 매니저가 어떤 느낌으로 필수적이라는 건지는 감이 딱 잡혔습니다.

그럼 동작 방식을 알아보면서 조금만 기술적으로 더 딥하게 들어가볼게요.

패키지 매니저는 기본적으로 `Resolution`, `Fetch`, `Link` 이렇게 3가지 단계로 동작합니다.

### Resolution 단계

> - 라이브러리 버전 고정
> - 라이브러리의 다른 의존성 확인
> - 라이브러리의 다른 의존성 버전 고정

Resolution은 말 그대로 `해결` 단계입니다. 무언가 문제가 발생했기 때문에 해결 단계가 생겼겠죠?

우선 첫 번째 문제, **라이브러리 버전 고정**입니다. 앞선 예시에서, 여러분은 에러가 수정된 친구표 라이브러리를 찾아 복사해서 사용했습니다. 앞으로도 <u>에러가 해결된 버전 이후의 친구 코드</u>를 긁어와야 한다는 거죠.

패키지 매니저는 이를 수행하기 위해 `package.json` 파일에 의존성의 버전을 명시하고, 이 버전 표기의 규칙에 따라 의존성의 버전을 선택합니다. 예를 들어, `"react": "^18.2.0"`라고 명시되어 있으면, `^`이 나타내는 규칙에 따라 `≥ 18.2.0`, `< 19.0.0` 사이의 어떤 버전이든 사용할 수 있습니다. 패키지 매니저는 이 범위를 만족하는 선에서 가능한 최신 버전을 사용하려고 합니다.

두 번째 발생하는 문제는 라이브러리가 사용하는 또다른 라이브러리, **의존성의 의존성 문제**입니다.

앞선 예시에서, 여러분은 에러가 수정된 친구표 라이브러리를 찾아 복사해서 사용했습니다. 하지만 친구표 라이브러리는 또 다른 라이브러리를 사용하고 있었죠. 그래서 여러분은 그 또 다른 라이브러리를 찾아 복사해서 사용해야 했습니다.

만약 여러분이 또 다른 라이브러리를 받아왔지만, 친구의 라이브러리에서 사용했던 라이브러리와 버전이 다를 때, 동일한 동작을 한다고 보장할 수 있을까요?

보장할 수 없습니다. 따라서 **의존성이 또 어떤 의존성을 가지는 지 확인하는 작업**이 꼭 필요합니다. 그리곤 그 **의존성의 의존성 버전도 고정하게 되고,** 마지막으로 그 결과물을 `package-lock.json` 혹은 `yarn.lock` 파일에 저장하게 됩니다.

그렇기 때문에 `package-lock.json` 혹은 `yarn.lock` 파일이 없을 경우 같은 `package.json`에 대해서도 사용하는 의존성 버전이 완전히 달라질 수 있게 됩니다.

이렇게 철저한 버전 고정을 통해 의존성 버전 문제를 해결하는 단계가 Resolution 단계입니다.

### Fetch 단계

> - 결정된 버전의 의존성들을 다운로드

Fetch는 Resolution 단계에서 결정된 버전을 기반으로 **의존성들을 다운로드**하는 아주 간단하고 심플한 단계입니다.

### Link 단계

> - Resolution/Fetch 된 의존성들을 소스 코드에서 사용할 수 있는 환경을 제공

핵심인 Link 단계입니다.

다운로드 받은 의존성들을 실제로 **어떻게 프로젝트에 저장하고, 탐색하고, 사용하는 지를 결정하는 단계**예요.

대표적인 패키지 매니저들의 주요 차이점은 이 Link 단계에서 발생하는데요. 한 번 차근차근 살펴보도록 합시다.

## 대표적인 패키지 매니저

패키지 매니저에는 대표적으로 아래 4가지가 존재합니다.

- npm
- yarn Classic
- yarn Berry
- pnpm

### npm (Node Package Manager)

Node.js 생태계의 가장 대표적인 패키지 매니저이자, 개발자들이 가장 익숙할 npm입니다.

npm은 `package.json`에서 명시하는 모든 의존성을 `node_modules` 폴더 밑에 하나하나씩 쓰는(저장하는) 방식인 npm Linker를 사용합니다.

만약 프로젝트에서 사용하는 의존성이 또 다른 의존성을 사용한다면, 그 의존성도 또 다시 해당 의존성의 `node_modules` 폴더 밑에 저장하게 됩니다.

```
reboot-project/
└─ node_modules/
   ├─ friend-library/
   |  └─ node_modules/
   |     └─ friend-friend-library
   └─ other-library/
      └─ node_modules/
          └─ other-library
```

결국 위와 같이 node_modules가 반복되는 형태가 되는 것이죠.

이런 방식은 프로젝트가 커질수록 크게 세 가지 문제가 발생하니다.

1. 디스크 공간을 많이 차지하게 됩니다. 실제로 파일 시스템에 중복된 node_modules 폴더와 의존성 데이터들이 저장되기 때문입니다.

   - 예를 들어 만약 사용중인 100가지 의존성이 모두 똑같은 react 의존성을 사용한다고 가정할 경우, 의존성의 개수만큼 `node_modules/의존성1~100/node_modules/react/node_modules/...` 이런 식으로 의존성 100까지 저장되게 됩니다.

2. 패키지에서 import를 통해 의존성을 읽으려고 할 경우, 해당 의존성을 찾기 위해 현재 패키지의 node_modules 폴더부터 찾고, 의존성을 찾지 못했을 경우 상위 node_modules로 타고타고 올라가면서 수많은 `node_modules`를 탐색하게 되는데, 이러한 I/O 호출이 반복되어 성능 저하가 발생할 수 있습니다.

3. 상위 node_modules 탐색의 특성 때문에, 패키지의 상위 디렉토리 환경에 따라 의존성 탐색 여부가 달라집니다. 다른 버전의 의존성을 잘못 불러올 수도 있습니다.

   - 2번, 3번 문제처럼 환경에 따라 동작이 변하는 것은 상당히 거슬리는 문제입니다. 잘 동작하다가도 언제 갑자기 문제가 터질지 알 수 없고, 문제가 터지더라도 이를 재현하기가 매우 까다롭기 때문입니다.

https://static.toss.im/ipd-tcs/toss_core/live/f600d9c8-ffb1-4df2-8ffe-c19f525f80a3/yarn-berry-1.png

#### 호이스팅과 유령 의존성

위 그림의 왼쪽 의존성 트리를 살펴보면 package-1 패키지에 A, C, D 의존성이 있습니다.
A는 또 다른 의존성으로 B를 가지고 있고, 또 C는 그런 A를 의존성으로 가집니다.
결과적으로 A -> B 의 의존성은 package-1 패키지 바로 아래, 그리고 C 아래에 총 두 번 설치되어 디스크 공간을 낭비하게 됩니다.

이를 해결하기 위해 npm과 yarn Classic에서는 원래 트리를 호이스팅하여 오른쪽 트리처럼 바꾸게됩니다.
모든 의존성을 검토한 뒤, 여러 패키지에서 공유할 수 있는 버전의 의존성이 존재한다면, 이들을 모두 최상단으로 끌어올려 버리는 겁니다.
위 리부트 서버 친구 라이브러리 예시에서 `내 프로젝트 -> 친구 라이브러리 -> 또다른 친구 라이브러리`로 형성된 의존성 트리에서, `친구 라이브러리`와 `또다른 친구 라이브러리`를 모두 그냥 패키지에 넣어버린 여러분처럼 말이에요.

하지만 이렇게 호이스팅을 하게 되면, 내 프로젝트에서 현재 **직접** 의존하고 있지 않은 라이브러리를 require할 수 있게 됩니다. 왼쪽 트리에서는 기본적으로 A, C, D를 의존하고 있기 때문에 B를 의존성으로 불러올 수 없었습니다. 자신이 루트이고, 현재 node_modules 폴더에는 A, C, D 밖에 없으니까 말이죠. 하지만 우측 트리로 호이스팅 되면서 이제 B 의존성을 직접 불러올 수 있게 되었습니다.

이러한 현상을 **유령 의존성(Phantom Dependency)** 이라고 부릅니다.

유령 의존성 현상이 발생할 경우, 여러분이 전혀 모르는, package.json에 명시되어 있지도 않은 라이브러리를 사용할 수 있게 됩니다. 그리고 이런 현상은 다른 의존성을 삭제할 때 다시 소리소문 없이 사라지기도 합니다.

어차피 모르는 라이브러리를 사용할 일이 뭐가 있냐 ! 뭐가 문제냐 ! 싶을 수도 있습니다.

만약 여러분의 프로젝트가 `moment` 라이브러리에 의존하고 있다고 가정합시다. 이 `moment` 라이브러리는 흔히 사용되는 `lodash`에 의존하는 라이브러리입니다.

이럴 경우 호이스팅으로 인해 lodash는 프로젝트의 package.json에 명시되어 있지 않지만, 직접 사용할 수 있게 됩니다.

아무것도 모른 채 당연하게 `lodash`를 사용하는 코드를 작성하고 개발을 완료했습니다.

하지만 어느 날 팀에서 `moment` 대신 `dayjs`를 사용하기로 결정하고 `moment`를 제거했다고 해봅시다.

그러면 잘 사용하고 있었던 `lodash`도 함께 사라져 문제가 발생할 수도 있는 것이죠.

### yarn Classic (v1)

yarn Classic은 2016년 페이스북에서 npm의 보안 및 성능 문제를 개선하여 npm을 대체하기 위해 새롭게 개발된 패키지 매니저입니다.

1. **병렬 설치로 인한 빠른 속도**

   - npm은 패키지를 순차적으로 설치
   - yarn은 여러 패키지를 병렬로 처리

2. **캐싱 시스템**

   - 다운로드 받은 패키지를 캐싱하여 재사용

3. **보안성**
   - 체크섬(checksum) 검증을 통한 패키지 무결성 검사
   - 패키지 자동 실행 제한

yarn이 개발된 당시에는 npm과 비교했을 때 위와 같은 강점들이 있었지만, 현재는 npm도 아래와 같은 많은 발전을 이루어 위 장점들이 대부분 상쇄되었습니다.

- npm도 v5부터 병렬 설치 지원
- npm도 패키지 캐싱 시스템 도입
- npm도 보안 기능 강화 (체크섬 검증 등)

따라서 현재 이러한 차이점들은 매우 미묘하며, 버전 잠금 파일명이나, 스크립트 명령어의 차이를 빼면 이제 거의 동일하다고 봐도 무방하다고 볼 수 있습니다.

[이미지](https://static.toss.im/ipd-tcs/toss_core/live/8ee7e7cc-769e-4acd-ada1-d43b39055e7e/yarn-berry-2.png)

### pnpm (Performant npm)

pnpm은 기존 npm의 `node_modules` 폴더를 그대로 유지하면서 **성능과 용량을 개선한 패키지 매니저**입니다.

이를 가능하게 한 것은 바로 **글로벌 저장소(`.pnpm-store`)와 하드 링크/심볼릭 링크**를 통한 접근 방식입니다.

<details>
<summary>**Linux의 하드링크/심볼링 링크를 쉽게 설명드려 볼게요!**</summary>

<div className="p-4 bg-neutral-50 rounded-lg">
우리는 보통 파일 안에 데이터가 있다고 생각합니다. 즉, `클릭 => 파일명 A -> 데이터`라고 생각합니다.

하지만 그 사이에는 `inode`라는 녀석이 하나 더 있습니다. `inode`는 파일 시스템에서 파일의 실제 데이터가 어디에 저장되어 있는 지 가리키는 포인터입니다.

그리고 우리가 흔히 부르는 `파일`은 사실 이 `inode`를 가리키는 포인터입니다.

[이미지]

즉, 데이터를 열기까지 `클릭 => 파일명 A -> inode #123 -> 실제 데이터` 이런 식으로 흘러가게 되는 것이죠.

### 하드 링크

하드 링크는 원본 파일과 동일한 inode를 직접적으로 가리킵니다.

```
파일명 A → inode #123 → 실제 데이터
파일명 B ↗
```

따라서 파일명 A(원본 파일)가 삭제되어도, 파일명 B(하드 링크)는 여전히 원본 파일의 inode를 가리키고 있기 떄문에, 파일명 B를 통해 원본 파일을 사용할 수 있습니다.

### 심볼링 링크 (소프트 링크)

심볼릭 링크는 파일이나 폴더를 가리키는 포인터 역할을 합니다. 쉽게 윈도우OS의 바로가기라고 생각하시면 편합니다.

따라서 원본 파일이 삭제되거나, 이동할 경우 심볼릭 링크는 더 이상 존재하지 않는 파일/디렉터리를 가리키게 되어 동작하지 않게 됩니다.

```
파일명 A → inode #123 → 실제 데이터
파일명 B → inode #124 → "파일명 A의 경로"
```

</div>
</details>

pnpm은 실제 의존성 데이터를 **글로벌 저장소(`.pnpm-store`)에 딱 한 번만 저장**한 뒤, 해당 의존성을 필요로 하는 프로젝트에는 글로벌 저장소의 의존성을 **하드 링크**로 참조하도록 합니다.

예시를 들어볼게요.

여러분이 프로젝트에서 `import React from 'react'`를 사용한다고 가정해봅시다.

우선 처음에는 `node_modules/react`를 찾아갑니다.

`node_modules/react`는 **심볼릭 링크**(바로가기)를 통해 `node_modules/.pnpm/react@18.2.0/node_modules/react`의 파일 경로를 가리킵니다.

그리고 `node_modules/.pnpm/react@18.2.0/node_modules/react`는 **하드 링크**를 통해 실제 데이터 저장 위치인 `.pnpm-store/react`를 가리킵니다.

```
.pnpm-store/
└── react의 실제 파일들
```

```
node_modules/
├── .pnpm/
│ └── react@18.2.0/
│    └── node_modules/
│       └── react/ <--- (.pnpm-store/react 와 하드링크)
└── react/ <--- (node_modules/.pnpm/react@18.2.0/node_modules/react 로 가는 심볼릭 링크)
```

그렇게 `node_modules` 폴더는 더이상 실제 의존성 데이터를 막 쌓아두는 게 아니라 심볼릭 링크를 통해 실제 데이터를 참조하는 역할만 수행하기 때문에 디렉토리 크기도 무척 작아집니다.

이렇게 단 한 번만 의존성을 저장하기 때문에, 의존성이 필요한 모든 패키지에서 불필요한 쓰기 작업을 반복할 필요가 없어져 디스크 공간 효율성과 속도 모두를 잡을 수 있었던 것이죠.

하지만 `node_modules` 폴더가 중첩적으로 의존성의 의존성 등에 존재하는 구조 자체는 바뀌지 않습니다.

이는 여전히 `node_modules` 를 타고타고 돌면서 의존성에 링크를 하나씩 걸고, 탐색해야 하기 때문에 아주 조금은 버벅일 수도 있다는 단점이 될 수 있습니다.

하지만 구조가 동일한 만큼 npm과의 호환성이 좋아서 npm을 쓰다가 pnpm으로 바꾸기만 했을 뿐인데 의존성 설치 속도와 용량이 줄어드는 경험을 볼 수 있었던 거죠.

결론적으로, pnpm은 다음과 같은 이점을 가집니다.

1. **디스크 공간 효율성**

   - 모든 프로젝트가 공유하는 단일 글로벌 저장소에 의존성을 저장
   - 하드 링크를 통해 실제 파일은 한 번만 저장되어 중복 설치 방지
   - 프로젝트별로는 심볼릭 링크만 생성되어 용량 절약

2. **빠른 설치 속도**

   - 이미 설치된 패키지는 하드 링크로 즉시 연결
   - 새로운 패키지만 다운로드하여 설치 시간 단축
   - 병렬 설치 지원

3. **엄격한 의존성 관리**

   - 각 패키지는 자신의 의존성에만 접근 가능
   - 유령 의존성 문제 해결
   - package.json에 명시된 의존성만 사용 가능

4. **npm 호환성**
   - node_modules 구조를 유지하여 기존 프로젝트와 호환
   - npm 명령어와 유사한 사용법으로 쉬운 전환
   - npm 레지스트리 완벽 지원

### yarn Berry (v2)

그런데, 굳이 `node_modules`를 계속 사용하는 이유가 뭘까요? 언제까지고 의존성을 탐색하기 위해 타고타고 돌아야 하는 걸까요?

yarn Berry는 이러한 `node_modules` 파일 시스템 구조로부터 벗어나기 위해 **PnP(Plug'n'Play)** 전략을 사용합니다.

yarn Berry는 `node_modules`를 **생성하지 않습니다**. 대신 `.yarn/cache` 폴더 밑에 `zip` 아카이브 파일 형태로 의존성 데이터를 저장하고, `.pnp.cjs` 파일에 의존성을 찾을 수 있는 정보를 기록합니다.

`.yarn/cache` 폴더 밑에는 각 의존성의 버전마다 단 하나의 zip 아카이브만이 존재합니다.

`.pnp.cjs`를 이용하면 디스크 I/O 없이 어떤 패키지가 어떤 라이브러리에 의존하는지, 또 각 라이브러리는 어디에 위치하는 지 바로 알 수 있습니다.

간단하게 `.pnp.cjs` 파일을 살펴보면 아래와 같은 형태로 이루어져 있습니다.

```js
{
  "packageRegistryData": [
    /* react 패키지 중에서 */
    ["react", [
      /* npm:17.0.1 버전은 */
      ["npm:17.0.1", {
        /* 이 위치에 있고 */
        "packageLocation": "./.yarn/cache/react-npm-17.0.1-95143125fc-a25f73ef98.zip/node_modules/react/",
        /* 이 의존성들에 의존한다. */
        "packageDependencies": [
          ["loose-envify", "npm:1.4.0"],
          ["object-assign", "npm:4.1.1"]
        ],
        /* 패키지가 .yarn/cache 내 zip 파일에 물리적으로 존재한다. */
        "linkType": "HARD"
      }],
    ]],
  ]
}
```

이 처럼 의존하는 패키지의 위치와 의존성의 의존성 목록까지 모두 명시되어 있는 것을 확인할 수 있습니다.

이를 활용하여 import 문으로 의존성을 불러올 때 디스크 I/O 없이 바로 의존성을 위치를 찾아 사용할 수 있게 되는거죠.

결론적으로, yarn Berry는 다음과 같은 이점을 가집니다.

1. node_modules 트리 구조와 폴더를 생성하지 않기 때문에 의존성 설치가 매우 빠릅니다.
2. 디스크 I/O 없이 의존성을 찾아 사용할 수 있기 때문에 의존성 탐색이 매우 빠릅니다.
3. 각 의존성 패키지의 버전마다 하나의 Zip 아카이브를 가지기 때문에 중복해서 설치되지 않고, 압축되어 있어 디스크 공간을 크게 절약할 수 있습니다.
4. 각 의존성 패키지들은 자신의 package.json에 명시된 의존성에만 접근할 수 있어 유령 의존성 현상이 발생하지 않습니다.

#### Zero-install

yarn Berry를 도입함으로써 의존성 버전마다 하나의 Zip 아카이브를 가지고, node_modules 폴더 구조마저 사라져버려 의존성을 구성하는 파일의 숫자와 용량이 크게 줄어들게 되었습니다.

이렇게 의존성 패키지들이 감당가능할 정도로 사이즈가 줄어들면, 굳이 의존성을 일일이 설치하는 작업이 필요하지 않을 것 같습니다. 그냥 설치한 의존성 패키지들을 그대로 Git을 통해 공유하고 싶습니다.

이렇게 yarn Berry에서 의존성을 버전 관리에 포함하는 것을 **Zero-install**이라고 합니다.

이렇게 의존성을 버전 관리에 포함하면 새로 레포지토리를 클론하거나 브랜치를 바꾸었을 때 의존성을 따로 설치하지 않아도 됩니다.

결과적으로 Zero-install을 사용하게 되면 설치된 의존성 패키지들이 모두 동일하기 때문에 잘못된 의존성 버전으로 인한 문제가 완전히 해결됩니다.

Zero-install은 yarn Berry에서만 활용하는 기술은 아닙니다.

그저 Resolution 단계와 Fetch 단계가 모두 완료된 결과물을 모두 버전 관리 시스템에 포함는 경우를 모두 Zero-install 이라고 부르는 거거든요.

따라서 npm을 사용하면서도 Zero-install을 사용할 수 있습니다. 하지만 설명드렸다시피 npm방식을 사용할 경우 중복된 의존성과 복잡한 node_modules 트리 구조로 인해 용량이 커지기 때문에 경제적이지 않아 사용하지 않는 거지요.

#### 철저히 잘 설계된 아키텍처

그 외에도 yarn Berry는 패키지 매니저의 각 단계 (Resolution, Fetch, Install)의 인터페이스가 잘 분리되어 있고 모듈화 되어 있다는 특징이 있습니다.

또한 PnP 방식으로 의존성을 엄격히 통제해 명시되지 않은 의존성을 사용하지 않도록 해요.

그리고 다양한 플러그인을 제공하여 확장 가능성이 높다는 장점도 있어요.

## 마무리하며

지금까지 패키지 매니저가 왜 필요한지, 어떻게 동작하는지, 그리고 대표적인 패키지 매니저들의 특징에 대해 알아보았습니다.

포스팅을 쭉 잘 따라오셨다면 이제 여러분은 처음에 제가 가졌던 의문들에 대해 자신있게 답변할 수 있을 겁니다.

<details>
<summary>패키지 매니저가 없다면?</summary>

1. **수동 다운로드와 관리**

   - 필요한 라이브러리의 소스 코드를 직접 다운로드하고, 수동으로 복사/붙여넣기를 진행해야 합니다.
   - 라이브러리의 버전 관리 및 업데이트를 수작업으로 진행해야 합니다.

2. **의존성 지옥**

   - 라이브러리 간의 의존성 관계를 수동으로 파악해야 합니다.
   - 서로 다른 의존성 버전의 충돌 문제가 발생합니다.
   - 중복 라이브러리 설치로 인한 프로젝트 크기가 증가합니다.

3. **표준화된 배포 방식 부재**
   - 라이브러리마다 설치 방법이 다를 수 있습니다.
   - 글로벌 네임스페이스 충돌 위험이 있습니다.

</details>

<details>
<summary>패키지 매니저는 왜 필요한거죠?</summary>

의존성 관리(의존성 설치/버전 관리/버전 충돌 등)를 자동화하고 표준화된 배포 방식을 제공하여 프로젝트 개발 환경을 개선하고 유지보수를 용이하게 합니다.

</details>

<details>
<summary>패키지 매니저의 종류는 왜 이렇게 다양하고, 뭐가 다른거죠?</summary>

각각의 패키지 매니저는 서로 다른 방식으로 의존성 관리 문제를 해결하려 했습니다.

- npm/yarn Classic: node_modules 중첩 구조와 호이스팅
- pnpm: 글로벌 저장소와 하드/심볼릭 링크
- yarn Berry: PnP 전략으로 node_modules 구조 자체를 제거

</details>

그리고 프로젝트에서 사용할 패키지 매니저를 충분한 근거와 기준을 토대로 선택할 수도 있을 겁니다.

저는 개인적으로 패키지 매니저를 다음과 같은 기준으로 선택합니다 !

기존에 진행하던 프로젝트에 참가한 경우에는 되도록 기존 패키지 매니저를 사용합니다.

하지만 만약 의존성 관리 문제가 발생하거나 프로젝트 크기가 커져 성능 이슈가 발생할 경우에는 보통 다음의 기준을 참고합니다.

1. **npm**

   - 가장 기본적이고 안정적인 선택
   - 별도의 학습 비용이 필요 없음
   - 최근 많은 성능 개선이 이루어짐
   - 하지만 여전히 node_modules 중첩 구조로 인한 성능/용량 이슈 존재

2. **yarn Classic**

   - npm과 거의 동일한 특성
   - 일부 추가 기능과 성능 개선
   - 하지만 npm의 발전으로 큰 차이는 없음

3. **pnpm**

   - 디스크 공간 효율성과 설치 속도가 중요할 때
   - 유령 의존성 문제를 해결하고 싶을 때
   - npm 생태계와의 호환성을 유지하고 싶을 때
   - node_modules 구조를 유지하면서 성능 개선이 필요할 때

4. **yarn Berry**
   - node_modules 구조 자체를 제거하고 싶을 때
   - Zero-install을 통해 의존성 설치 과정을 완전히 제거하고 싶을 때
   - 의존성 관리의 혁신적인 변화를 원할 때
   - 하지만 일부 라이브러리와의 호환성 문제 가능성 존재

## 출처

[Toss Tech - 패키지 매니저의 과거, 토스의 선택, 그리고 미래](https://toss.tech/article/lightning-talks-package-manager)

[Toss Tech - node_modules로부터 우리를 구원해 줄 yarn Berry](https://toss.tech/article/node-modules-and-yarn-berry)

[어린소:티스토리 - 하드 링크/심볼링 링크](https://young-cow.tistory.com/44)
